# [cf1840D] [Wooden Toy Festival](https://codeforces.com/problemset/problem/1840/D)


## 题目描述
In a small town, there is a workshop specializing in woodwork. Since the town is small, only **three** carvers work there.

Soon, a wooden toy festival is planned in the town. The workshop employees want to prepare for it.

They know that $n$ people will come to the workshop with a request to make a wooden toy. People are different and may want different toys. For simplicity, let's denote the pattern of the toy that the $i$\-th person wants as $a_i$ ($1 \le a_i \le 10^9$).

Each of the carvers can choose an integer pattern $x$ ($1 \le x \le 10^9$) in advance, **different carvers can choose different patterns**. $x$ is the integer. During the preparation for the festival, the carvers will perfectly work out the technique of making the toy of the chosen pattern, which will allow them to cut it out of wood instantly. To make a toy of pattern $y$ for a carver who has chosen pattern $x$, it will take $|x - y|$ time, because the more the toy resembles the one he can make instantly, the faster the carver will cope with the work.

On the day of the festival, when the next person comes to the workshop with a request to make a wooden toy, the carvers can choose who will take on the job. At the same time, the carvers are very skilled people and can work on orders for different people **simultaneously**.

Since people don't like to wait, the carvers want to choose patterns for preparation in such a way that the **maximum** waiting time over all people is as **small** as possible.

Output the best maximum waiting time that the carvers can achieve.


---

## 题目大意
> 给你一个数组 $a$ ，你可以任意选择 $3$ 个数，设 $diff$ 为每个 $a[i]$ 与这 $3$ 个数的差的绝对值的最小值（ $min(|a[i] - x_1|, |a[i] - x_2|, |a[i] - x_3|)$ ）。你需要**最小化**每个 $a[i]$ 的 $diff$ 的**最大值**。


---

## 输入

> 一个整数 $t$ ，表示测试数据的组数。

> 对于每组测试数据：一个整数 $n$ 表示 $a$ 数组的长度。数组 $a$ 的每个值, $a[i]$ 都在 $[1, 10^9]$ 范围内。



## 输出

> 输出一个整数，表示最小化每个 $a[i]$ 的 $diff$ 的**最大值**。

---

## 我的思路

**二分答案**

> 二分最大的答案 $diff$ ，对于每个 $diff$ 能覆盖地范围为 $[0, 2*diff]$ 也就是 $2*diff$ 。

> 我们将数组先从小到大进行排序，**贪心地考虑**，第一个开始是 $min(a)$ 是**最优的**，即 $last = a[0] + 2*diff$ 。接着我们开始枚举每个 $a[i]$ 如果当前 $a[i] > last$ ，即不再上一个覆盖的范围，那么我们开始一个新的覆盖范围，同样最优的是 $a[i] + 2*diff$ 。我们**最多**可以开启**三个**覆盖范围，因为题目只能让我们任意选择 $3$ 个整数。




---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
	"sort"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		slices.Sort(a)
		mx := slices.Max(a)
		ans := sort.Search(mx+1, func(time int) bool {
			cnt := 1
			last := a[0] + 2*time
			for _, x := range a {
				if x > last {
					cnt++
					last = x + 2*time
				}
				if cnt > 3 {
					return false
				}
			}
			return true
		})
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(a, b int) int {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}

func max64(x, y int64) int64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y int64) int64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
---

## JavaScript 代码

```JavaScript
```