# [cf1856C] [To Become Max](https://codeforces.com/problemset/problem/1856/C)

## 题目描述
You are given an array of integers $a$ of length $n$.

In one operation you:

-   Choose an index $i$ such that $1 \le i \le n - 1$ and $a_i \le a_{i + 1}$.
-   Increase $a_i$ by $1$.

Find the maximum possible value of $\max(a_1, a_2, \ldots a_n)$ that you can get after performing this operation at most $k$ times.

---

## 题目大意
给您一个长度为 $n$ 的整数数组 $a$ 。

在一次操作中，您：

- 选择索引 $i$ ，使得 $1 \le i \le n - 1$ 和 $a_i \le a_{i + 1}$ 。
- 将 $a_i$ 增加 $1$ 。

求执行此操作最多 $k$ 次后可以获得的最大可能值 $\max(a_1, a_2, \ldots a_n)$ 。


---

## 输入




## 输出

> 

---

## 我的思路

**二分答案**

> 二分猜测可以得到的最大值，由于每次操作都是**相邻**的元素且得**单调不减**，我们可以通过样例可以发现最大值出现的**区间一定是单调不增**的，且**最大值**一定是枚举区间的**第一个**。

> 那么我们验证猜测答案的可行性的方法即为从枚举区间的第一个位置开始对 $kk$ 进行减少（为了不改变 $k$ ，我们每次枚举用一个临时变量 $kk$ 来验证），并且使用一个 $tar$ 表示当前位置需要变成最终单调不增序列的目标值，每次操作后当前位置 $tar$ 就可以减一（可以通过样例验证），如果 出现了 $a[i] >= tar$ （说明当前位置已经就是最终值了）那么就可以说明我们验证的答案是可行的，即 $kk$ 有剩余。如果枚举时 $kk < 0$ 了，直接 $break$ 就行。




---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
	"sort"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, k int
		Fscan(in, &n, &k)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		mx := slices.Max(a)
		ans := sort.Search(mx+k+1, func(mx int) bool {
			for i := range a {
				kk := k
				tar := mx
				for _, v := range a[i:] {
					if v >= tar {
						return false
					}
					kk -= tar - v
					if kk < 0 {
						break
					}
					tar--
				}
			}
			return true
		}) - 1
		ans = max(ans, slices.Max(a))
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```
