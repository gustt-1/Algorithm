# [cf1907D] [Jumping Through Segments](https://codeforces.com/problemset/problem/1907/D)

## 题目描述
Polycarp is designing a level for a game. The level consists of $n$ segments on the number line, where the $i$\-th segment starts at the point with coordinate $l_i$ and ends at the point with coordinate $r_i$.

The player starts the level at the point with coordinate $0$. In one move, they can move to any point that is within a distance of no more than $k$. After their $i$\-th move, the player must land within the $i$\-th segment, that is, at a coordinate $x$ such that $l_i \le x \le r_i$. This means:

-   After the first move, they must be inside the first segment (from $l_1$ to $r_1$);
-   After the second move, they must be inside the second segment (from $l_2$ to $r_2$);
-   ...
-   After the $n$\-th move, they must be inside the $n$\-th segment (from $l_n$ to $r_n$).

The level is considered completed if the player reaches the $n$\-th segment, following the rules described above. After some thought, Polycarp realized that it is impossible to complete the level with some values of $k$.

Polycarp does not want the level to be too easy, so he asks you to determine the minimum integer $k$ with which it is possible to complete the level.

---
## 题目大意
$Polycarp$ 正在为游戏设计一个关卡。该级别由数轴上的 $n$ 段组成，其中第 $i$ 段从坐标为 $l_i$ 的点开始，到坐标为 $r_i$ 的点结束。

玩家从坐标为 $0$ 的点开始关卡。一次移动，他们可以移动到距离不超过 $k$ 内的任何点。在第 $i$ \-次移动之后，玩家必须降落在第 $i$ \-th 段内，即在坐标 $x$ 处，使得 $l_i <= r_i$ 。这意味着：

- 第一次移动后，它们必须位于第一段内（从 $l_1$ 到 $r_1$ ）；
- 第二次移动后，它们必须位于第二段内（从 $l_2$ 到 $r_2$ ）；
- $...$
- 第 $n$ 个移动之后，它们必须位于第 $n$ 个段内（从 $l_n$ 到 $r_n$ ）。

如果玩家按照上述规则到达第 $n$ 段，则认为该关卡已完成。经过一番思考， $Polycarp$ 意识到使用 $k$ 的某些值是不可能完成关卡的。

$Polycarp$ 不希望关卡太简单，因此他要求您确定可以完成该关卡的最小整数 $k$ 。


## 输入

>


## 输出

>

---

## 我的思路
**二分答案**

> 由于第一个 $l[i]$ 是可能最大为 $1e9$ ，又因为我们要落到每个段中，所以最大的 $k$ 可能是 $1e9$ ，我们二分 $k$ 的大小然后判断 $k$ 的合法性

> 对于每个 $k$ ，如果当前 $ll = max(ll-k, l[i])$ 即我们找最小的 $ll$ ，我们可以向左移动最多 $k$ 个单位，和线段左端点比一个较大值； $rr = min(rr+k, r[i])$ ，我们可以像右移动的最大值和线段右端点比一个较小值。如果 $ll < rr$ （我们`下一个线段的左端点`比我们`从上一个地方`可以移动的**最大值**`大`,说明**不能**到下一个线段）直接为 $false$ ，若所有都可以就返回 $true$ 。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"sort"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		l, r := make([]int, n), make([]int, n)
		for i := range n {
			Fscan(in, &l[i], &r[i])
		}
		ans := sort.Search(int(1e9), func(k int) bool {
			ll, rr := 0, 0
			for i := range n {
				ll = max(ll-k, l[i])
				rr = min(rr+k, r[i])
				if rr < ll {
					return false
				}
			}
			return true
		})
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python
```
