# [cf2000D] [Right Left Wrong](https://codeforces.com/problemset/problem/2000/D)

## 题目描述
Vlad found a strip of $n$ cells, numbered from left to right from $1$ to $n$. In the $i$\-th cell, there is a positive integer $a_i$ and a letter $s_i$, where all $s_i$ are either 'L' or 'R'.

Vlad invites you to try to score the maximum possible points by performing any (possibly zero) number of operations.

In one operation, you can choose two indices $l$ and $r$ ($1 \le l < r \le n$) such that $s_l$ = 'L' and $s_r$ = 'R' and do the following:

-   add $a_l + a_{l + 1} + \dots + a_{r - 1} + a_r$ points to the current score;
-   replace $s_i$ with '.' for all $l \le i \le r$, meaning you can no longer choose these indices.

For example, consider the following strip:

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$ |
|  --- | --- | --- | --- | --- | ---  |
| L | R | L | L | L | R |

You can first choose $l = 1$, $r = 2$ and add $3 + 5 = 8$ to your score.

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$ |
|  --- | --- | --- | --- | --- | ---  |
| . | . | L | L | L | R |

Then choose $l = 3$, $r = 6$ and add $1 + 4 + 3 + 2 = 10$ to your score.

| $3$ | $5$ | $1$ | $4$ | $3$ | $2$ |
|  --- | --- | --- | --- | --- | ---  |
| . | . | . | . | . | . |

As a result, it is impossible to perform another operation, and the final score is $18$.

What is the maximum score that can be achieved?

---


## 输入

>


## 输出

>

---

## 我的思路
**双指针**
> https://github.com/EndlessCheng

> 输入 `T(≤1e4)` 表示 `T` 组数据。所有数据的 `n` 之和 `≤2e5` 。
每组数据输入 $n(2 ≤ n ≤ 2^5)$ ，长为 `n` 的数组 $a(1 ≤ a_i≤ 1^5)$，长为 $n$ 的字符串 $s$ ，只包含大写字母 `'L'` 和 `'R'` 。

> 每次操作：
选择 $a$ 的一个子数组 $[i,j]$ ，满足 $s[i] = L$ 且 $s[j] = R$ 。
获得等于子数组 $[i,j]$ 的元素和的分数。
把 $s$ 的子串 $[i,j]$ 中的字符全部改成 '.'。

> 输出总得分的最大值。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		a := make([]int, n)
		cnt := make([]int, n+1)
		for i := range a {
			Fscan(in, &a[i])
			cnt[i+1] = cnt[i] + a[i]
		}
		var s string
		Fscan(in, &s)
		ans := 0
		l, r := 0, n-1
		for l < r {
			if s[l] == 'L' && s[r] == 'R' {
				ans += cnt[r+1] - cnt[l]
				r--
				l++
			} else if s[l] == 'R' {
				l++
			} else if s[r] == 'L' {
				r--
			}
		}
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
