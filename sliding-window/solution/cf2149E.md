# [cf2149E] [Hidden Knowledge of the Ancients](https://codeforces.com/problemset/problem/2149/E)

## 题目描述
In the world of Deepwoken, there exists an ancient artifact — Tablet of Infinite Knowledge, on which a sequence of $n$ mysterious symbols (each symbol is an integer) is engraved.

It is said that the true power of the artifact can only be revealed by finding all sacred fragments — continuous segments of the tablet that contain exactly $k$ distinct numbers, and their length must be between $l$ and $r$ (inclusive).

Formally: Given a sequence $a$ of length $n$ and integers $k$, $l$, $r$. You need to find the number of such boundaries $b$ and $c$ such that:

-   $1 \le b \le c \le n$;
-   among the elements \[ $a_{b}, a_{b + 1}, \dots, a_{c}$ \] there are exactly $k$ distinct numbers;
-   $l \leq c - b + 1 \leq r$.

---
## 题目大意
给定一个数组 $a$ ，有多少个连续子数组 $b$ ，满足 $b$ 的长度在 $[L,R]$ 中，且 $b$ 恰好有 $k$ 个不同元素。


## 输入

>


## 输出

>

---

## 我的思路
**不定长恰好型滑动窗口**

> 我们用 `f(n)` 来统计 $a$ 中满足不同元素个数`最多`为 `n` 的`子数组个数`为多少。那么不同元素个数`恰好`为 `k` 的子数组个数即为 `f(k) - f(k-1)` 。由于子数组长度要在 $L - R$ 之间，
当右端点在 $rr$ 时，设 $ll$ 是**最小的满足要求的左端点**。那么子数组长度**最大**为 $min(rr-ll+1, R)$ ，**最小**为 $L$ 。所以有 $min(rr-ll+1,R) - L + 1$ 个右端点为 $rr$ 的子数组。但这不能是负数，所以有 $max(min(rr-ll+1,R) - L + 1, 0)$ 个右端点为 $rr$ 的子数组。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, k, l, r int
		Fscan(in, &n, &k, &l, &r)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		f := func(tar int) (res int) {
			cnt := map[int]int{}
			ll := 0
			for rr, v := range a {
				cnt[v]++
				for len(cnt) > tar {
					w := a[ll]
					cnt[w]--
					if cnt[w] == 0 {
						delete(cnt, w)
					}
					ll++
				}
				res += max(min(rr-ll+1, r)-l+1, 0)
			}
			return
		}
		Fprintln(out, f(k)-f(k-1))
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
