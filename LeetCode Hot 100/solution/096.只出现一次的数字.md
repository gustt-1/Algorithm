# [只出现一次的数字](https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个 非空 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。


## 样例

- 示例 $1$ ：

    输入：`nums = [2,2,1]`

    输出：`1`

- 示例 $2$ ：

    输入：`nums = [4,1,2,1,2]`

    输出：`4`

- 示例 $3$ ：

    输入：`nums = [1]`

    输出：`1`



## 数据范围

> $1 <= nums.length <= 3 * 10^4$

> $-3 * 10^4 <= nums[i] <= 3 * 10^4$

> 除了某个元素只出现一次以外，其余每个元素均出现**两次**。


## 我的思路

**位运算**

> 由于题目说明除了出现一次的数其他数都出现了两次。我们可以利用异或运算 $a⊕a=0$ 的性质。例如我们有一个数组 `nums = [1,2,1,5,5]` 。由于是异或运算我们初始化 `ans = 0` ，我们把所有数异或起来那就是 $(1 ⊕ 2 ⊕ 1 ⊕ 5 ⊕ 5) == ((1 ⊕ 1) ⊕ (5 ⊕ 5) ⊕ 1) == (0 ⊕ 0 ⊕ 1) == 1$ ，我们所有元素异或起来就是答案。

**两个相同的非负整数异或和等于零，异或运算有交换律和结合律**

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(1)$

---

## Go 代码

```Go
func singleNumber(nums []int) (ans int) {
    for _, x := range nums {
        ans ^= x
    }
    return
}
```
---

## C++ 代码

```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for (int x : nums) {
            ans ^= x;
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # ans = 0
        # for _, x in enumerate(nums):
        #     ans ^= x
        # return ans
        return reduce(xor, nums)
```

## JavaScript 代码

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    let ans = 0;
    for (const x of nums) {
        ans ^= x;
    }
    return ans;
};
```
