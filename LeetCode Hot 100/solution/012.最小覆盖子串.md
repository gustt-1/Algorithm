# [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。如果 `s` 中存在这样的子串，我们保证它是唯一的答案。**

## 样例

- 示例 $1$：

    输入：`s = "ADOBECODEBANC", t = "ABC"`

    输出：`"BANC"`

    解释：`最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。`
- 示例 $2$：

    输入：`s = "a", t = "a"`

    输出：`"a"`

    解释：`整个字符串 s 是最小覆盖子串。`
- 示例 $3$:

    输入: `s = "a", t = "aa"`

    输出: `""`

    解释: `t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。`


## 数据范围

> $m == s.length$

> $n == t.length$

> $1 <= m, n <= 10^5$

> $s$ 和 $t$ 由英文字母组成


## 我的思路

**滑动窗口**

> 我们先预处理一个统计数组 `cnt` ，表示为 `s` 的子数组中还需要多少个 `t` 中的字符，同时我们记录 `t` 中字符的**种类数**为 `total` 。

`cnt` 的值即为我们窗口内 **`缺少`的 t 的个数**， `total` 表示我们还有**多少种** `t` 字符**没有包含**

> 我们使用滑动窗口，假设窗口**左右端点**为 `r, l` 。我们 `r` **进入窗口**，那么我们 `cnt[s[r]]--` 表示我们**包含了** `t` 中的一些字符。如果 `cnt[s[r]]--` **后**发现 `cnt[s[r]] == 0` 说明我们 `s[r]` **这种字符**已经包含了，那么我们 `totol--` 。**左端点** `l` **退出**窗口，如果 `cnt[s[l]] == 0` 即左端`还未退出时`我们是`恰好`包含 `s[l]` **这种**字符的，**离开窗口后我们就不再包含了**，那么我们就又还有一种字符未包含那么 `total++` 并且 `cnt[s[l]]++` 。

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(26)$ ，为字母的种类

---

## Go 代码

```Go
func minWindow(s string, t string) string {
    cnt := [128]int{}
    total := 0
    for _, x := range t {
        if cnt[x] == 0 {
            total++
        }
        cnt[x]++
    }
    ansl, ansr := -1, len(s)
    l := 0
    for r, c := range s {
        cnt[c]--
        if cnt[c] == 0 {
            total--
        }
        for total == 0 {
            if r-l < ansr - ansl {
                ansr, ansl = r, l
            }
            cc := s[l]
            if cnt[cc] == 0 {
                total++
            }
            cnt[cc]++
            l++
        }
    }
    if ansl < 0 {
        return ""
    }
    return s[ansl: ansr+1]
}
```
---

## C++ 代码

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        int cnt[128]{};
        int total = 0;
        for (auto c : t) {
            if (cnt[c] == 0) {
                total++;
            }
            cnt[c]++;
        }
        int ansl = -1, ansr = s.size();
        int l = 0;
        for (int r = 0; r < s.size(); r++) {
            auto c = s[r];
            cnt[c]--;
            if (cnt[c] == 0) {
                total--;
            }
            while (total == 0) {
                if (r - l < ansr - ansl) {
                    ansr = r, ansl = l;
                }
                auto cc = s[l];
                if (cnt[cc] == 0) {
                    total++;   
                }
                cnt[cc]++;
                l++;
            }
        }
        
        return ansl == -1 ? "" : s.substr(ansl, ansr-ansl+1);
    }
};
```
---
## Python 代码

```Python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        cnt = defaultdict(int)
        for c in t:
            cnt[c] += 1
        total = len(cnt)

        l = 0
        ansl, ansr = -1, len(s)
        
        for r, c in enumerate(s):
            cnt[c] -= 1
            if cnt[c] == 0:
                total -= 1
            
            while total == 0:
                if r - l < ansr - ansl:
                    ansl, ansr = l, r
                cc = s[l]
                if cnt[cc] == 0:
                    total += 1
                cnt[cc] += 1
                l += 1

        return "" if ansl == -1 else s[ansl:ansr+1]
```

## JavaScript 代码

```JavaScript
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
    const cnt = Array(128).fill(0);
    let total = 0;
    for (let c of t) {
        c = c.codePointAt(0);
        if (cnt[c] === 0) {
            total++;
        }
        cnt[c]++;
    }

    let l = 0;
    let ansl = -1, ansr = s.length;

    for (let r = 0; r < s.length; r++) {
        const c = s.charCodeAt(r);
        cnt[c]--;
        if (cnt[c] === 0) total--;

        while (total === 0) {
            if (r - l < ansr - ansl) {
                ansl = l;
                ansr = r;
            }
            const cc = s.charCodeAt(l);
            if (cnt[cc] === 0) {
                total++;
            }
            cnt[cc]++;
            l++;
        }
    }

    return ansl === -1 ? "" : s.substring(ansl, ansr + 1);
};
```
