# [移动零](https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给定一个数组 `nums` ，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。


## 样例

- 示例 $1$:

    输入: `nums = [0,1,0,3,12]`

    输出: `[1,3,12,0,0]`

- 示例 $2$:

    输入: `nums = [0]`

    输出: `[0]`




## 数据范围
> $1 <= nums.length <= 10^4$

> $-2^{31} <= nums[i] <= 2^{31} - 1$




## 我的思路

**双指针**

> 我们用 $zero$ 来标记下一个 `非零元素` 要交换的位置。如果我们遇到了零，就让 `zero标记` ，如果遇到了非零就跟下标 $zero$ 交换，并让 `zero++` 。

**我们举个例子**

> 样例 $1$：`nums = [0,1,0,3,12]` ，此时 `i = 0,zero = 0,nums[i] = 0` ，遇到了 $0$ ，就让 $zero$ 停留，表示要交换的位置；那么来到 `i = 1,zero = 0,nums[i] = 1` ，那就交换变成 `nums = [1,0,0,3,12] 并且zero++` ；接着 `i = 2,zero = 1,nums[i] = 0,zero 停留`；继续 `i = 3, zero = 1, nums[i] = 3` ，交换变成 `nums = [1,3,0,0,12]，zero++` ；接着 `i = 4, zero = 2, nums[i] = 12` ，交换得到 `nums = [1,3,12,0,0]` ，即得到了最终结果。

> 如果遇到了 $0$ ，那就停留标记，遇到了非零就是把非零元素向前移动的过程。由于非零情况下是 $i$ 和 $zero$ 一起更新的，所以相当于是两两交换向前移动（我感觉像冒泡排序）

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(1)$ 

---

## Go 代码

```Go

func moveZeroes(nums []int)  {
    zero := 0
    for i, x := range nums {
        if x != 0 {
            nums[i], nums[zero] = nums[zero], nums[i]
            zero++
        }
    }
}


```
---

## C++ 代码

```C++

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int zero = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != 0) {
                swap(nums[i], nums[zero]);
                zero++;
            }
        }
    }
};


```
---
## Python 代码

```Python

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        zero = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[zero], nums[i] = nums[i], nums[zero]
                zero += 1


```



## JavaScript 代码

```JavaScript

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let zero = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            [nums[i], nums[zero]] = [nums[zero], nums[i]];
            zero++;
        }
    }
};

```
