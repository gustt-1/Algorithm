# [颜色分类](https://leetcode.cn/problems/sort-colors/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给定一个包含**红色、白色和蓝色**、共 `n` 个元素的数组 `nums` ，**原地** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 $0、 1$ 和 $2$ 分别表示红色、白色和蓝色。必须在不使用库内置的 `sort `函数的情况下解决这个问题。



## 样例

- 示例 $1$：

    输入：`nums = [2,0,2,1,1,0]`

    输出：`[0,0,1,1,2,2]`
- 示例 $2$：

    输入：`nums = [2,0,1]`

    输出：`[0,1,2]`



## 数据范围

> $n == nums.length$

> $1 <= n <= 300$

> $nums[i]$ 为 $0、1$ 或 $2$


## 我的思路

**荷兰国旗问题/三指针**

> 由于 `0, 1, 2` 要分别在数组中的`左中右`位置，我们可以用三个指针 `l = 0`, `m = 0`, `r = n - 1 `来表示`左边`，`当前`，`右边`枚举。

**怎么交换呢？**

> 1.如果我们当前的 `nums[m] == 0` 说明这个该去左边，那么跟我们 `l 指针`的位置元素交换。并且让 `l++` 表示下一个可能的 `0` 交换的位置，并且也让 `r++` 去判断下一个。

> 2.如果我们当前 `nums[m] == 1` 说明已经在正确位置了我们直接 `m++` 就行

> 3.如果当前 `nums[m] == 2` ，说明这个位置的元素改在右边我们跟 `r 指针`位置的元素交换，并且让 `r++` ，但是**不能**让 `m++` ，因为我们**并没有判断**换过来的 `nums[r]` ，我们得让 `m 指针`**停留**，我们再判断一下当前的 `nums[m]` 。

> 细心的话可以察觉我们第一种情况是为什么直接就让 `m++` 了。我们是否还没有判断原来的 `nums[l]` （即交换后的`nums[r]`）呢？其实我们**已经判断过了**，因为我们是**从左向右**遍历的，换来的是 `nums[l]` 只能是 $1$ 。为啥？因为如果是 $2$ 我们在之前肯定是给他**换到右边**去了；并且由于我们之前的操作 `l` 一定是指向的排序后的**第一个 1** 。

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(1)$

---

## Go 代码

```Go
func sortColors(nums []int)  {
    l, r := 0, len(nums) - 1
    m := 0
    for m <= r {
        x := nums[m]
        if x == 0 {
            nums[l], nums[m] = nums[m], nums[l]
            l++
            m++
        } else if x == 1 {
            m++
        } else {
            nums[m], nums[r] = nums[r], nums[m]
            r--
        }
    }
}
```
---

## C++ 代码

```C++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int l = 0, m = 0, r = nums.size() - 1;
        while (m <= r) {
            if (nums[m] == 0) {
                swap(nums[l], nums[m]);
                l++;
                m++;
            } else if (nums[m] == 1) {
                m++;
            } else {
                swap(nums[m], nums[r]);
                r--;
            }
        }
    }
};
```
---
## Python 代码

```Python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        l, m, r = 0, 0, len(nums) - 1
        while m <= r:
            if nums[m] == 0:
                nums[l], nums[m] = nums[m], nums[l]
                l += 1
                m += 1
            elif nums[m] == 1:
                m += 1
            else:
                nums[m], nums[r] = nums[r], nums[m]
                r -= 1
```

## JavaScript 代码

```JavaScript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
    let l = 0, m = 0, r = nums.length - 1;

    while (m <= r) {
        if (nums[m] === 0) {
            [nums[l], nums[m]] = [nums[m], nums[l]];
            l++;
            m++;
        } else if (nums[m] === 1) {
            m++;
        } else {
            [nums[m], nums[r]] = [nums[r], nums[m]];
            r--;
        }
    }
};
```
