# [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的**最大值** 。

## 样例

- 示例 $1$：

    输入：`nums = [1,3,-1,-3,5,3,6,7], k = 3`

    输出：`[3,3,5,5,6,7]`

    解释：

    滑动窗口的位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    最大值
    ---------------                 -----
    `[1  3  -1] -3  5  3  6  7   |  3`

    `1 [3  -1  -3] 5  3  6  7    | 3`

    `1  3 [-1  -3  5] 3  6  7    | 5`

    `1  3  -1 [-3  5  3] 6  7    | 5`

    `1  3  -1  -3 [5  3  6] 7    | 6`

    `1  3  -1  -3  5 [3  6  7]   | 7`

- 示例 $2$：

    输入：`nums = [1], k = 1`

    输出：`[1]`



## 数据范围

> $1 <= nums.length <= 10^5$

> $-10^4 <= nums[i] <= 10^4$

> $1 <= k <= nums.length$


## 我的思路

**单调队列**

> 我们维护一个队列，其中队首为**当前窗口的最大值的`下标`**，而队列其他元素则为可能的最大值。如果当前元素 `x` **大于**队列的`队尾`，说明队尾**不可能**为当前窗口的最大值了，因为有 `x` 的存在， `x` **可能**为窗口的最大值，那么我们将 `x` 的下标加入到队尾。我们在取得当前的窗口的**左端点** `cur = i - k + 1` ，如果队首 `q[0] > cur` 说明 `q[0]` **已经不是这个窗口内的元素了**（注意我们用的是 `if` ，而不是 `for`，因为我们**每一步都会检查一次**，所以不需要循环）。那么我们将 `q[0]` $pop$ 掉。更新最大值 `ans[cur] = q[0]` 。

**答案数组长度为 $len(nums) - k + 1$**

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## Go 代码

```Go
func maxSlidingWindow(nums []int, k int) []int {
    ans := make([]int, len(nums)-k+1)
    q := []int{}
    
    for i, x := range nums {
        for len(q) > 0 && nums[q[len(q)-1]] < x {
            q = q[:len(q)-1]
        }
        q = append(q, i)
        cur := i - k + 1
        if q[0] < cur {
            q = q[1:]
        }
        if cur >= 0 {
            ans[cur] = nums[q[0]]
        }
    }
    return ans
}
```
---

## C++ 代码

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        deque<int> q;

        for (int i = 0; i < n; i++) {
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            q.push_back(i);

            int left = i - k + 1;
            if (q.front() < left) {
                q.pop_front();
            }

            if (left >= 0) {
                ans[left] = nums[q.front()];
            }
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ans = [0] * (len(nums) -k + 1)
        q = deque()
        
        for i, x in enumerate(nums):
            while q and nums[q[-1]] <= x:
                q.pop()
            q.append(i)
            cur = i - k + 1
            if q[0] < cur:
                q.popleft()
            if cur >= 0:
                ans[cur] = nums[q[0]]
        return ans
```

## JavaScript 代码

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    const ans = [];
    const q = new Deque();

    for (let i = 0; i < nums.length; i++) {
        while (!q.isEmpty() && nums[q.back()] <= nums[i]) {
            q.popBack();
        }
        q.pushBack(i);
        const cur = i - k + 1;
        if (q.front() < cur) {
            q.popFront();
        }
        if (cur >= 0) {
            ans.push(nums[q.front()]);
        }
    }
    return ans
};
```
