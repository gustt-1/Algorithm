# [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给定两个字符串 $s$ 和 $p$ ，找到 $s$ 中所有 $p$ 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**注：字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。**

## 样例

- 示例 $1$:

	输入: `s = "cbaebabacd", p = "abc"`

	输出: `[0,6]`

	解释:起始索引等于 `0` 的子串是 `"cba"`, 它是 `"abc"` 的异位词。起始索引等于 `6` 的子串是 `"bac"`, 它是 `"abc"` 的异位词。
- 示例 $2$:

	输入: `s = "abab", p = "ab"`

	输出: `[0,1,2]`

	解释:起始索引等于 `0` 的子串是 `"ab"`, 它是 `"ab"` 的异位词。起始索引等于 `1` 的子串是 `"ba"`, 它是 `"ab"` 的异位词。起始索引等于 `2` 的子串是 `"ab"`, 它是 `"ab"` 的异位词。



## 数据范围

> $1 <= s.length, p.length <= 3 * 10^4$

> **s 和 p 仅包含小写字母**


## 我的思路

**滑动窗口**

> 我们使用一个 $cnt$ 数组记录 $p$ 中各个字符的数目，我们滑窗的思路即是使得 $cnt$ 中每个字符的数目都是 $0$ 即 $s$ 中已经包含了 $p$ 中**所有的字符**。我们来到的位置 $i$ ，如果我们的 $cnt[s[i]]$ **小于零**，说明**太多了!** 我们则缩小窗口。因为字母异位词是 p 中字符的一个**排列**，所以我们的窗口大小只能是 $p$ 的长度，那我们在 `r - l + 1 == len(p)` 时更新答案。

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $s$ 的长度

---

## 空间复杂度

$O(σ)$ ， $σ=26$ 是字符集合的大小。

---

## Go 代码

```Go
func findAnagrams(s string, p string) (ans []int) {
    cnt := [26]int{}
    for _, c := range p {
        cnt[c-'a']++
    }
    l := 0
    for r, c := range s {
        c -= 'a'
        cnt[c]--
        for cnt[c] < 0 {
            cnt[s[l]-'a']++
            l++
        }
        if r-l+1 == len(p) {
            ans = append(ans, l)
        }
    }
    return
}
```
---

## C++ 代码

```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        int cnt[26] = {0};
        for (char c : p) cnt[c - 'a']++;
        int l = 0;
        for (int r = 0; r < s.size(); r++) {
            char c = s[r];
            cnt[c - 'a']--;
            while (cnt[c - 'a'] < 0) {
                cnt[s[l] - 'a']++;
                l++;
            }
            if (r - l + 1 == p.size()) ans.push_back(l);
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        ans = []
        cnt = Counter(p)
        l = 0
        for r, c in enumerate(s):
            cnt[c] -= 1
            while cnt[c] < 0:
                cnt[s[l]] += 1
                l += 1
            if r-l+1 == len(p):
                ans.append(l)
        return ans
```

## JavaScript 代码

```JavaScript
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function(s, p) {
    const n = s.length, m = p.length;
    if (n < m) return [];
    const cnt = new Array(26).fill(0);
    for (let c of p) {
        cnt[c.charCodeAt(0) - 97]++;
    }
    const ans = [];
    let l = 0;
    
    for (let r = 0; r < n; r++) {
        cnt[s.charCodeAt(r) - 97]--;
        while (cnt[s.charCodeAt(r) - 97] < 0) {
            cnt[s.charCodeAt(l) - 97]++;
            l++;
        }
        if (r - l + 1 === m) ans.push(l);
    }
    return ans;
};
```
