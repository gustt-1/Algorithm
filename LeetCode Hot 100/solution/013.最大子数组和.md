# [最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个整数数组 `nums` ，请你找出一个具有**最大和**的连续子数组（子数组最少包含一个元素），返回其**最大和**。

**`子数组`是数组中的一个连续部分。**

## 样例

- 示例 $1$：

    输入：`nums = [-2,1,-3,4,-1,2,1,-5,4]`

    输出：`6`

    解释：`连续子数组 [4,-1,2,1] 的和最大，为 6 。`
- 示例 $2$：

    输入：`nums = [1]`

    输出：`1`
- 示例 $3$：

    输入：`nums = [5,4,-1,7,8]`

    输出：`23`


## 数据范围

> $1 <= nums.length <= 10^5$

> $-10^4 <= nums[i] <= 10^4$


## 我的思路

**动态规划**

> 最大子数组和，我们定义 $f[i]$ 为以 $i$ 位置为结尾的最大子数组和。那么我们的转移方程即为 $f[i] = max(f[i-1] + nums[i], nums[i])$ 。即如果来到 `i` 位置，如果和前面以 `i - 1` 为结尾的最大子数组和相加跟以 `i` 为`结尾`（就以 `i` 位置**单独为一个子数组**）相比较，如果 `f[i-1] + nums[i] < nums[i] `即我还不如我自己`单独一个`大呢！

**状态转移方程为 $f[i] = max (f[i-1] + nums[i], nums[i]) $**

> 根据我们的状态转移方程可知，我们 $i$ 位置的状态`只依赖于前一个位置的状态`，那么我们可以进行空间优化，即`一个变量`来表示前一个位置的状态。

**由于题目数组长度一定大于 $0$ ，所以不需要特判数组长度等于 $0$ 的情况**

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(1)$

---

## Go 代码

```Go
func maxSubArray(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    ans := nums[0]
    maxsum := nums[0]

    for i := 1; i < n; i++ {
        maxsum = max(maxsum + nums[i], nums[i])
        ans = max(ans, maxsum)
    }
    return ans
}
```
---

## C++ 代码

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        int ans = nums[0];
        int maxsum = nums[0];
        for(int i = 1;i < n;i++){
            maxsum = max(maxsum + nums[i],nums[i]);
            ans = max(maxsum,ans);
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def maxSubArray(self, nums: list[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        
        ans = nums[0]
        maxsum = nums[0]
        for i in range(1, n):
            maxsum = max(maxsum + nums[i], nums[i])
            ans = max(ans, maxsum)
        return ans
```

## JavaScript 代码

```JavaScript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    const n = nums.length;
    if (n == 0) {
        return 0;
    }
    [maxsum, ans] = [nums[0], nums[0]];
    for (let i = 1; i < n; i++) {
        maxsum = Math.max(maxsum + nums[i], nums[i]);
        ans = Math.max(ans, maxsum);
    }
    return ans;
};
```
