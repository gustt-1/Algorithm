# [合并区间](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你`合并所有重叠的区间`，并返回 `一个不重叠`的区间数组，该数组需恰好覆盖输入中的所有区间 。

## 样例

- 示例 $1$：

    输入：`intervals = [[1,3],[2,6],[8,10],[15,18]]`

    输出：`[[1,6],[8,10],[15,18]]`

    解释：`区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].`
- 示例 $2$：

    输入：`intervals = [[1,4],[4,5]]`

    输出：`[[1,5]]`

    解释：`区间 [1,4] 和 [4,5] 可被视为重叠区间。`
- 示例 $3$：

    输入：`intervals = [[4,7],[1,4]]`

    输出：`[[1,7]]`

    解释：`区间 [1,4] 和 [4,7] 可被视为重叠区间。`


## 数据范围

> $1 <= intervals.length <= 10^4$

> $intervals[i].length == 2$

> $0 <= start_i <= end_i <= 10^4$

## 我的思路

**排序**

> 根据题目大意，容易想到我们可以按照`左端的的位置`进行`排序`，这样方便我们进行合并区间。我们用一个答案数组，我们**不断地判断答案数组的`最后一个`**。

> 要是来到的 `i` 位置的数，左右端点即为 `l = intervals[i][0], r = intervals[i][1]` 。由于我们是排序了的，所以 `l` 一定是比答案数组最后一个数 `ans[len(ans)-1][0]` 要大的，所以我们只需要判断 `r` 和 `ans[len(ans)-1][1]` 的大小关系即可。如果 `r <= ans[len(ans)-1][1]` 那么我们直接更新 `ans[len(ans)-1][1] = r `。

> 同时我们也需要判断答案数组`是否为空`，`为空`我们`直接加入当前元素`就很好了。


---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $intervals$ 的长度

---

## 空间复杂度

$O(n)$ ，其中 $n$ 是 $intervals$ 的长度

---

## Go 代码

```Go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, x := range intervals {
        n := len(ans)
        if n > 0 && x[0] <= ans[n-1][1] {
            ans[n-1][1] = max(ans[n-1][1], x[1])
        } else {
            ans = append(ans, x)
        }
    }
    return ans
}
```
---

## C++ 代码

```C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        ranges::sort(intervals);
        vector<vector<int>> ans;
        for (auto &x : intervals) {
            if (!ans.empty() && ans.back()[1] >= x[0]) {
                ans.back()[1] = max(ans.back()[1], x[1]);
            } else {
                ans.emplace_back(x);
            }
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda i: i[0])
        ans = []
        for _, x in enumerate(intervals):
            n = len(ans)
            if n > 0 and ans[n-1][1] >= x[0]:
                ans[-1][1] = max(ans[-1][1], x[1])
            else:
                ans.append(x)
        return ans
```

## JavaScript 代码

```JavaScript
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    intervals.sort((a, b) => a[0] - b[0])
    const ans = []
    for (const x of intervals) {
        const n = ans.length
        if (n > 0 && ans[n-1][1] >= x[0]) {
            ans[n-1][1] = Math.max(ans[n-1][1], x[1])
        } else {
            ans.push([...x])
        }
    }
    return ans
};
```
