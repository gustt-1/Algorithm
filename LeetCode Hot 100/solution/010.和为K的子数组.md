# [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 该数组中和为 `k` 的子数组的个数 。

**子数组是数组中元素的连续非空序列。**

## 样例

- 示例 $1$：

    输入：`nums = [1,1,1], k = 2`

    输出：`2`
- 示例 $2$：

    输入：`nums = [1,2,3], k = 3`

    输出：`2`



## 数据范围

> $1 <= nums.length <= 2 * 10^4$

> $-1000 <= nums[i] <= 1000$

> $-10^7 <= k <= 10^7$


## 我的思路

**枚举右维护左/哈希/前缀和**

> 假如来到 `i` 位置，根据前缀和的知识，子数组和即为 `target = sum[i] - sum[j]` ，即我们要找到一个 `j` 使得 `target = k` 。我们可以维护一个哈希表 `cnt ` 来记录**每个位置所累加的前缀和的个数**（由于我们的数组元素可能为负数，所以一个前缀和可能存在多个个数，不是单调递增的）。假设我们当前位置累加的为 `sum` ，我们只需要判断 `cnt[sum-k] (sum[i] - sum[j] = k -> sum[j] = sum[i] - k)` 是否等于零即可，如果`不等于零`我们就**累加到答案中**，等于零说明**不存在**。

**注意初始化 $cnt[0] =1$**
---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(m)$ ，$m$ 为不同前缀的个数 

---

## Go 代码

```Go
func subarraySum(nums []int, k int) (ans int) {
    cnt := make(map[int]int)
    cnt[0] = 1
    sum := 0
    for _, x := range nums {
        sum += x
        val, ok := cnt[sum-k]; if ok {
            ans += val
        }
        cnt[sum]++
    }
    return
}
```
---

## C++ 代码

```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        int ans = 0;
        int sum = 0;
        cnt[0] = 1;
        for (auto x : nums) {
            sum += x;
            ans += cnt.contains(sum - k) ? cnt[sum - k] : 0;
            cnt[sum]++;
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        cnt = defaultdict(int)
        cnt[0] = 1
        ans = 0
        total = 0
        for _, x in enumerate(nums):
            total += x
            ans += cnt[total-k]
            cnt[total] += 1
        return ans
```

## JavaScript 代码

```JavaScript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function(nums, k) {
    const cnt = new Map()
    cnt.set(0, 1)
    let ans = 0, sum = 0
    for (let x of nums) {
        sum += x
        if (cnt.has(sum-k)) {
            ans += cnt.get(sum-k)
        }
        cnt.set(sum, (cnt.get(sum) || 0) + 1)
    }
    return ans
};
```
