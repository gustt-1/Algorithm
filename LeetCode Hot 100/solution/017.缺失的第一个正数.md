# [缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 $O(n)$ 并且只使用常数级别额外空间的解决方案。

## 样例

- 示例 $1$ ：
  
  输入：`nums = [1,2,0]`
  
  输出：`3`
  
  解释：范围 `[1,2]` 中的数字都在数组中。

- 示例 $2$ ：
  
  输入：`nums = [3,4,-1,1]`
  
  输出：`2`
  
  解释： $1$ 在数组中，但 $2$ 没有。

- 示例 $3$ ：
  
  输入：`nums = [7,8,9,11,12]`
  
  输出：`1`
  
  解释：最小的正数 $1$ 没有出现。



## 数据范围
> $1 <= nums.length <= 10^5$

> $-2^{31} <= nums[i] <= 2^{31} - 1$




## 我的思路

**原地哈希**

> 我们要找到最小的未出现的正数，我们可以将每一个数都类比成一个学生，每一个学生都有一个学号（即本身的值），我们将每一个学生都安排在正确的位置（即数组下标加一等于他的学号，**数组下标从零开始所以要加一**），我们找到第一个学生和位置不匹配的即是我们要找的答案。如果全部学生都位置正确那么就是数组长度 $n+1$ 。

注：不匹配条件是 $nums[i] != nums[nums[i]-1]$

> 数据全是大于 $0$ 且不重复，我们看第一个样例 `nums = [1,2,0]` ，我们正确交换能交换的所有学生后的数组为 `nums = [1,2,0]` 。我们第一个不匹配的位置是 $i = 2$ ，由于下标是从零开始，那么我们的答案即是 $i+1=3$ 。

> 数据如果有负数，我们看第二个样例 `nums = [3,4,-1,1]` ，我们进行交换位置得到 `nums = [1,-1,3,4]` ，第一个不匹配的是 $i=1$ ，那么我们的答案即是 $i+1=2$ 。

> 如果有重复数字，我们看一个自编样例 `nums = [2,4,1,3,1]` ，我们交换后得到 `nums = [1,2,3,4,1]` ，第一个不匹配的是 $i=4$ ，所以我们的答案是 $i+1=5$ 。对于重复元素，我们可以视为这个同学有特异功能，他会分身！但是老师却只是个普通人，他分辨不出哪个是真正的他，无奈，只能把所有的他都当成真的。为了确保其他同学做到满意的位置，老师只能将那个特异功能的同学安排一个正确的位置，其他同学优先考虑，如果再遇到那个特异功能的同学那就跳过。这时看我们的判断条件， $nums[i] != nums[nums[i]-1]$  ，假设有一个 $1$ 在 $i=0$ 位置（正确位置），还有一个在 $i=3$ 。当我们碰到 $i=3, nums[i=3] = 1 == nums[nums[i=3]=1-1=0] = 1$ 。不符合我们内层的循环条件所以跳过了。

**从上面的分类讨论可以得出我们的判断条件是符合所有情况的。**

##
---

## 时间复杂度

$O(n)$

---

## 空间复杂度

$O(1)$

---

## Go 代码

```Go

func firstMissingPositive(nums []int) int {
    n := len(nums)
    for i := range n {
        for 1 <= nums[i] && nums[i] <= n && nums[i] != nums[nums[i]-1] {
            j := nums[i] - 1
            nums[i], nums[j] = nums[j], nums[i]
        }
    }
    for i := range n {
        if nums[i] != i+1 {
            return i+1
        }
    }
    return n
}


```
---

## C++ 代码

```C++

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            while (1 <= nums[i] && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                int j = nums[i] - 1;
                swap(nums[i], nums[j]);
            }
        }

        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
};

```
---
## Python 代码

```Python

class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            while 1 <= nums[i] and nums[i] <= n and nums[i] != nums[nums[i]-1]:
                j = nums[i] - 1
                nums[i], nums[j] = nums[j], nums[i]
        for i in range(n):
            if nums[i] != i+1:
                return i+1
        return n+1

```



## JavaScript 代码

```JavaScript

/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
    const n = nums.length
    for (let i = 0; i < n; i++) {
        while (1 <= nums[i] && nums[i] <= n && nums[i] !== nums[nums[i]-1]) {
            const j = nums[i] - 1;
            [nums[i], nums[j]] = [nums[j], nums[i]]
        }
    }
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) {
            return i + 1
        }
    }
    return n + 1
};

```
