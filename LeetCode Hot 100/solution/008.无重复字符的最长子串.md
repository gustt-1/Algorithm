# [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给定一个字符串 $s$ ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**注：子字符串是字符串中`连续且非空`的字符序列。**

## 样例

- 示例 $1$:

	输入: `s = "abcabcbb"`

	输出: `3` 

	解释: 因为无重复字符的最长子串是 `"abc"`，所以其长度为 `3`。
- 示例 $2$:

	输入: `s = "bbbbb"`

	输出: `1`

	解释: 因为无重复字符的最长子串是 `"b"`，所以其长度为 `1`。
- 示例 $3$:

	输入: `s = "pwwkew"`

	输出: `3`

	解释: 因为无重复字符的最长子串是 `"wke"`，所以其长度为 `3`。请注意，你的答案必须是 **子串** 的长度，`"pwke"` 是一个**子序列**，**不是子串**。



## 数据范围

> $0 <= s.length <= 5 * 10^4$

> **s由英文字母、数字、符号和空格组成**


## 我的思路

**滑动窗口**

> 由于题目是子串，那么我们可以考虑用滑动窗口来维护无重复字符的子串，在满足条件的情况下更新最大值即可。

> 我们用一个哈希表来记录当前窗口是否包含当前子符，如果已经包含了那么我们缩小窗口直到不包含为止。

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $s$ 的长度

---

## 空间复杂度

$O(σ)$ ， $σ$ 为字符串中字符种类的数量 

---

## Go 代码

```Go
func lengthOfLongestSubstring(s string) (ans int) {
    has := make(map[byte]bool)
    l := 0
    for r := 0; r < len(s); r++{
        for has[s[r]] {
            delete(has, s[l])
            l++
        }
        has[s[r]] = true
        ans = max(ans, r-l+1)
    }
    return
}
```
---

## C++ 代码

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> hash;
        int ans = 0;
        for(int l = 0, r = 0; l < s.size() && r < s.size(); r++){
            while(hash.find(s[r]) != hash.end()){
                hash.erase(s[l++]);
            }
            hash.insert(s[r]);
            ans = max(ans,r - l + 1);
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        hash_set = set()
        ans = l = 0
        for r in range(len(s)):
            while s[r] in hash_set:
                hash_set.remove(s[l])
                l += 1
            hash_set.add(s[r])
            ans = max(ans, r - l + 1)
        return ans
```

## JavaScript 代码

```JavaScript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    const has = new Map();
    let ans = 0, l = 0;
    for (let r = 0; r < s.length; r++) {
        while (has.get(s[r])) {
            has.delete(s[l]);
            l++;
        }
        has.set(s[r], true);
        ans = Math.max(ans, r - l + 1);
    }
    return ans;
};
```
