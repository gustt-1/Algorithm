# [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0) 和 (i, height[i])` 。找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。

**说明：你不能倾斜容器。**


## 样例

- 示例 $1$：
    输入：`[1,8,6,2,5,4,8,3,7]`

    输出：`49 `

    解释：图中垂直线代表输入数组 `[1,8,6,2,5,4,8,3,7]`。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 `49`。

- 示例 $2$：

    输入：`height = [1,1]`

    输出：`1`




## 数据范围

> $n == height.length$

> $2 <= n <= 10^5$

> $0 <= height[i] <= 10^4$


## 我的思路

**双指针**

> 盛水最多，我们贪心地思考，这个容器肯定越宽越好。那么我们可以用双指针，指针 $l, r$ 分别表示容器左边高和右边高。我们盛水是取决于较短的那一边，我们用 $ans$ 来记录每一步的成水量，取 $max$ 。我们开始向中间缩小，由于每一步我们都要缩小一个单位的宽度，我们肯定是保留较高的那一边是最优的，我们的循环出口是 $l < r$ ，最后返回 $ans$ 即可。

> 如何证明这个双指针的正确性呢？我们思考固定一个柱子，由于盛水量取决于较短的。我们最左和最右考虑，此时 $L = 0, R = n - 1$ ，宽度是最宽的，记盛水量为 `V` ，我们保留较短的那一根柱子（假设是 `L` ），那么我们的宽度就会减一。我们再考虑盛水量，记为 `V'`，我们可以得到 `V > V'`。由于我们保留的是较短的（假设我们一直保留 `L`），那么如果我们后面 `R'` 处比 `L` 处更高的，但由于 `L` 更短并且宽度还减小了，那 `V'` 肯定是 `小于V ` 的（高度不变，宽度减小，所以整体减小），比 $L$ 处的更小那就更不用说了。

> 可以知道我们保留短的，后面的情况一定不会比一开始的大所以可以直接省略（我们没有漏掉情况），保留更高的才有无限可能！！！



---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $height$ 的长度

---

## 空间复杂度

$O(1)$ 

---

## Go 代码

```Go
func maxArea(height []int) (ans int) {
    n := len(height)
    l, r := 0, n-1
    for l < r {
        ans = max(ans,min(height[l],height[r]) * (r - l))
        if height[l] > height[r] {
            r--
        } else {
            l++
        }
    }
    return
}
```
---

## C++ 代码

```C++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int ans = 0;
        while (l < r) {
            ans = max(ans, min(height[l], height[r]) * (r - l));
            if (height[l] > height[r]) {
                r--;
            } else {
                l++;
            }
        }
        return ans;
    }
};
```
---
## Python 代码

```Python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        ans = 0
        while l < r:
            ans = max(ans,min(height[l],height[r]) * (r - l))
            if height[l] > height[r]:
                r -= 1
            else:
                l += 1
        return ans
```



## JavaScript 代码

```JavaScript
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    let ans = 0;
    let l = 0, r = height.length - 1;
    while (l < r) {
        if (height[l] < height[r]) {
            ans = Math.max(ans, height[l] * (r - l));
            l++;
        } else {
            ans = Math.max(ans, height[r] * (r - l));
            r--;
        }
    }
    return ans;
};
```
