# [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个只包含 `(` 和 `)` 的字符串，找出最长有效（格式正确且连续）括号 `子串` 的长度。左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 `"(()())"`。

**子字符串是字符串中连续的字符序列。**

## 样例

- 示例 $1$：

    输入：`s = "(()"`

    输出：`2`

    解释：最长有效括号子串是 `"()"`
- 示例 $2$：

    输入：`s = ")()())"`

    输出：`4`

    解释：最长有效括号子串是 `"()()"`
- 示例 $3$：

    输入：`s = ""`

    输出：`0`


## 数据范围

> $0 <= s.length <= 3 * 10^4$

> $s[i]$ 为 `(` 或 `)`


## 我的思路

**动态规划**

> 我们定义一个 $f$ 数组，为了避免讨论越界情况，我们将 $f$ 数组长度设为 $n + 1$ ，那么 $f[i+1]$ 表示以下标 $i$ 位置**结尾**的最长有效括号，即来到 **第** `i + 1`个位置。

**$s[i]$ 对应 $f[i+1]$**


> 当来到的 $i$ 位置（第 $i+1$ 个位置）时，`s[i] == '('`。由于我们当前是 `(`，无论前面怎么样，以当前结尾的最长有效括号都是 0 。

> 当来到的 $i$ 位置（第 $i+1$ 个位置）时，`s[i] == ')'`。此时我们才有可能以当前位置结尾形成有效括号。
  - 如果前一个位置 `s[i-1] == '('`，那么 `s[i]` 和 `s[i-1]` 就可以**刚好组成一对**，我们就可以加上 `f[i-1]`。例如 `s = "()()"` ，来到 `i = 3` ，即 `s[i] == ')'`，并且 `s[i-1] == '('`。再加上前面的已经形成的，那么 `i` 位置的 `f[i+1] = f[i-1] + 2`，即前 `i - 2` 形成的有效括号长度和刚好形成的长度为 $2$ 的有效括号。
  - 如果前一个位置 `s[i-1] == ')'`。我们按 `pos = i - f[i] - 1` 位置的情况分类讨论。例如： `s = "( ) &(& ( ) &)&"`，我们看用 `&&` 包起来的两个括号，一个是我们**来到的位置**，一个是看的 **`pos`位置**。我们需要知道 `pos 位置括号的情况`。因为 `pos = i - f[i] - 1` ，即 `s[i-1]` 处可以形成的最长有效括号**前一个位置**。我们分情况讨论。
    - 如果 `s[pos] == ')'`，我们无法与 `s[i]` 位置形成有效括号，那么 `f[i+1] = 0`。例如 `s = "( ) &)& ( ) &)&"`
    - 如果 `s[pos] == '('`，那么我们可以和 `s[i]` 位置形成有效括号。并且我们还可以加上 pos 前一个位置可以形成的有效括号。则 `f[i+1] = f[i] + 2 + f[pos]`。

    **注意判断`pos >= 0` ，因为我们需要判断 `s[pos]` 。**
    
> 最后答案即是 $f$ 数组中的**最大值**
---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $s$ 的长度

---

## 空间复杂度

$O(n)$，其中 $n$ 是 $s$ 的长度

---

## Go 代码

```Go
func longestValidParentheses(s string) int {
    n := len(s)
    f := make([]int, n+1)
    for i, ss := range s {
        if ss == '(' {
            f[i+1] = 0
        }
        if ss == ')' {
            if i == 0 {
                f[i+1] = 0
            }
            if i >= 1 && s[i-1] == '(' {
                f[i+1] = f[i-1] + 2
            } else if i >= 1 && s[i-1] == ')'{
                pos := i - f[i] - 1
                if pos >= 0 && s[pos] == '(' {
                    f[i+1] = f[i] + 2 + f[pos]
                } else {
                    f[i+1] = 0
                }
            }
        }
    }
    return slices.Max(f);
}
```
---

## C++ 代码

```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.size();
        vector<int> f(n + 1, 0);

        for (int i = 0; i < n; i++) {
            if (s[i] == '(') {
                f[i + 1] = 0;
            } else if (s[i] == ')') {
                if (i >= 1 && s[i - 1] == '(') {
                    f[i + 1] = f[i - 1] + 2;
                } else if (i >= 1 && s[i - 1] == ')') {
                    int pos = i - f[i] - 1;
                    if (pos >= 0 && s[pos] == '(') {
                        f[i + 1] = f[i] + 2 + f[pos];
                    } else {
                        f[i + 1] = 0;
                    }
                } else {
                    f[i + 1] = 0;
                }
            }
        }
        
        return *max_element(f.begin(), f.end());
    }
};
```
---
## Python 代码

```Python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        f = [0] * (n + 1)

        for i, ch in enumerate(s):
            if ch == '(':
                f[i + 1] = 0
            elif ch == ')':
                if i == 0:
                    f[i + 1] = 0
                elif s[i - 1] == '(':
                    f[i + 1] = f[i - 1] + 2
                elif s[i - 1] == ')':
                    pos = i - f[i] - 1
                    if pos >= 0 and s[pos] == '(':
                        f[i + 1] = f[i] + 2 + f[pos]
                    else:
                        f[i + 1] = 0
                        
        return max(f)
```

## JavaScript 代码

```JavaScript
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function(s) {
    const n = s.length;
    const f = Array(n+1).fill(0);
    for (let i = 0; i < n; i++) {
        const cur = s[i];
        if (cur == '(') {
            f[i+1] = 0;
        } else {
            if (i == 0) {
                f[i+1] = 0;
            }
            if (i >= 1 && s[i-1] == '(') {
                f[i+1] = f[i-1] + 2;
            } else if (i >= 1 && s[i-1] == ')') {
                const pos = i - f[i] - 1;
                if (pos >= 0 && s[pos] == '(') {
                    f[i+1] = f[i] + 2 + f[pos]
                } else {
                    f[i+1] = 0
                }
            }
        }
    }
    return Math.max(...f)
};
```
