# [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 $O(n)$ 的算法解决此问题。


## 样例

- 示例 $1$：
  
    输入：`nums = [100,4,200,1,3,2]`
  
    输出：`4`
  
    解释：最长数字连续序列是 `[1, 2, 3, 4]`。它的长度为 $4$ 。

- 示例 $2$：
  
    输入：`nums = [0,3,7,2,5,8,4,6,0,1]`
  
    输出：`9`

- 示例 $3$：
  
    输入：`nums = [1,0,1,2]`
  
    输出：`3`




## 数据范围
> $0 <= nums.length <= 10^5$

> $-10^9 <= nums[i] <= 10^9$




## 我的思路

**哈希表**

> 我们先将每个数都存入到哈希表中，然后我们对哈希表进行遍历。对于每一个 $x$ ，我们用 $y = x + 1$ 来表示下一个数，然后我们看下一个数是否在哈希表中，即能不能再原数组中找到下一个数 $y = x + 1$ 。我们用循环直到不能找到。由于我们的子序列是一个差值为 $1$ 的等差数列，所以我们的长度即为 $y - x$ 。

**有一个优化为 `if has[x-1] { continue }` -> 如果 x 不是序列的起点，直接跳过**

> 注意：我们每次都要判断 $x-1$ 是否在哈希表中，即判断我当前数为起点的子序列是否是在另一个子序列中。 例如：假设一个子序列 $s1$ 为 `2,3,4,5,6` ，假设当前是 $4$ ，我们以 $4$ 为起点能找到一个子序列 $s2$ 为 `4，5，6` ，但是 $s2$ 是 $s1$ 的一个子序列，我们在计算起点为 $1$ 的时候已经计算过了。如果我们不加这个优化，我们的时间复杂度就可能退化为 $O(n^2)$ ，即我们遍历每一个数都当作起点，那就是暴力了。

##
---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

$O(m)$ ，其中 $m$ 是 $nums$ 中的不同元素个数。

---

## Go 代码

```Go

func longestConsecutive(nums []int) (ans int) {
    has := map[int]bool{}
    for _, x := range nums {
        has[x] = true
    }
    for x := range has {
        if has[x-1] {
            continue
        }
        y := x + 1
        for has[y] {
            y++
        }
        ans = max(ans, y-x)
    }
    return 
}


```
---

## C++ 代码

```C++

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> st(nums.begin(), nums.end());
        int ans = 0;
        for (int x : st) {
            if (st.contains(x - 1)) {
                continue;
            }
            int y = x + 1;
            while (st.contains(y)) {
                y++;
            }
            ans = max(ans, y - x);
            if (ans * 2 >= st.size()) {
                break;
            }
        }
        return ans;
    }
};


```
---
## Python 代码

```Python

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        has = set(nums)
        ans = 0
        for x in has:
            if x - 1 not in has:
                y = x + 1
                while y in has:
                    y += 1
                ans = max(ans,y-x)
        return ans


```



## JavaScript 代码

```JavaScript

/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    const st = new Set(nums);
    let ans = 0;
    for (const x of st) {
        if (st.has(x - 1)) {
            continue;
        }
        let y = x + 1;
        while (st.has(y)) {
            y++;
        }
        ans = Math.max(ans, y - x);
        if (ans * 2 >= st.size) {
            break;
        }
    }
    return ans;
};

```
