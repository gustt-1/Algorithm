# [接雨水](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给定 $n$ 个非负整数表示每个宽度为 $1$ 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。


## 样例

- 示例 $1$：

	输入：`height = [0,1,0,2,1,0,1,3,2,1,2,1]`

	输出：`6`

	解释：上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的高度图（略），在这种情况下，可以接 `6` 个单位的雨水（蓝色部分表示雨水）。 
- 示例 $2$：

	输入：`height = [4,2,0,3,2,5]`

	输出：`9`

## 数据范围

> $n == height.length$

> $1 <= n <= 2 * 10^4$

> $0 <= height[i] <= 10^5$


## 我的思路
**预处理前后缀/双指针/单调栈**

---
> 首先我们得清楚，如果能接雨水的话是必须得形成一个凹槽例如高度为 `[3,1,3]` ，则能接 $2$ 单位的雨水。如果一格一格地看，我们要想知道当前位置能不能接水，接多少水是取决于他是否被包裹住即需要知道**左边最大高度**和**右边最大高度**。并且总是取决于最大高度的较小值（一个木桶能装多少水取决于最短的那个木板的高度）

**1.预处理前后缀**

> 我们可以预处理出来每个位置的**前缀最大**以及**后缀最大**，对于每个位置我们取一个较小值，减去当前位置的高度即是当前位置能接到的雨水量。 $res = min(per[i], suf[i]) - height[i]$ 。

**2.双指针**

> 预处理的空间复杂度是 $O(n)$ 的，预处理也要时间，能不能优化呢？我们使用左右双指针来更新。

> 其实只要我们知道当前位置的前缀最大或后缀最大哪个**更小**就行了，至于更大的那一边有多大我们不需要去关注，因为取决的是较小的那边。例如：`height = [5,6,3,1,4,2]` ，我们来到高度为 $4$ 的位置，假设我们左右双指针 $l, r$ ， $l$ 来到 $5$ ， $r$ 来到 $4$ ，此时我们知道 $4 < 5$ ，我们是否可以直接更新答案？是可以的，因为我们已经明确知道了高度为 $1$ 的右边的最大值为 $4$ ，我们接水量只取决于 4 这个柱子。至于左边的高度为 $6$ 的这根柱子我们可以不用考虑了。

> 所以双指针思路即是用 $l, r$ 两个指针维护前后缀最大值的较小值。判断哪个更小，我们更新较小柱子的旁边那个位置。例如 `l = 2, r = 8` ，假设 `height[l] < height[r]` ，那么我们更新 $l + 1$ 位置。


**3.单调栈**

> 前两种方法都是直接计算来到当前位置在整个容器中能借多少水，我们还可以换种角度，我们思考对于形成的一个凹槽我们一步一步灌水看他能装多少。

> 我们举个例子，假设高度为`height = [5,3,1,4]`，因为 $5, 4$ 我们把 $3, 1$ 围住形成了一个凹槽，由于 $1$ 最小，我们灌`[3,1,4]`区间水，首先灌满的是 $1$ 位置，因为 $3 < 4$ ，取决于 $3$ ，那么我们可以灌注 $2 * 1 = 2$ （ 高度为 $3 - 1 = 2$ ，宽度为 $1$）个单位的水。因为 $1$ 位置灌注的水跟 $3$ 高度一样了，那么就变成了 `[5,3,3,4]` ，我们接着灌水就是区间`[5,3,3,4]`，由于 $4 < 5$ ，那么我们可以灌注 $1 * 2 = 2$ （高度为 $1$ ，宽度为 $2$ ）个单位的水。

> 我们则是要找到当前位置**下一个比他高**的柱子的位置，那么我们考虑用一个**单调递减栈维护下标**

> 只要来到的位置比栈顶大，那么我们就弹出栈顶更新，我们再计算**宽度和高度**更新答案。

---

## 时间复杂度

$O(n)$ ，其中 $n$ 是 $nums$ 的长度

---

## 空间复杂度

预处理前后缀为 $O(1)$ ；双指针为 $O(1)$ ；单调栈为 $O(min(n,U))$ ，其中 $U=max(height)−min(height)+1$ 。注意栈中没有重复元素，在 $height$ 值域很小的情况下，空间复杂度主要取决于 $height$ 的值域范围。

---

## Go 预处理前后缀代码

```Go
func trap(height []int) (ans int) {
    n := len(height)
    pre := make([]int, n)
    suf := make([]int, n)
    pre[0] = height[0]
    for i := 1; i < n; i++ {
        pre[i] = max(pre[i-1], height[i])
    }
    suf[n-1] = height[n-1]
    for i := n-2; i >= 0; i-- {
        suf[i] = max(suf[i+1], height[i])
    }
    for i := 0; i < n; i++ {
        ans += min(pre[i], suf[i]) - height[i]
    }
    return
}
```
---


## Go 双指针代码

```Go
func trap(height []int) (ans int) {
    n := len(height)
    lmax, rmax := height[0], height[n-1]
    for l, r := 0, n-1; l < r; {
        lmax = max(lmax,height[l])
        rmax = max(rmax,height[r])
        if lmax > rmax {
            ans += rmax - height[r]
            r--
        } else {
            ans += lmax - height[l]
            l++
        }
    }
    return
}
```
---

## Go 单调栈代码

```Go
func trap(height []int) (ans int) {
    st := []int{}    //维护一个单调递减栈的下标
    for i, x := range height {
        for len(st) > 0 && height[st[len(st)-1]] < x {   //可以储水
            r := st[len(st)-1]      //获取右边界
            st = st[:len(st)-1]      //出栈
            if len(st) == 0 {     //栈为空了->左边没有柱子了
                break
            }
            l := st[len(st)-1]    //获取左边界的下标
            h := min(height[l], x) - height[r]   //计算可以储水的高度
            w := i - l - 1    //计算宽度
            ans += h * w   //加入答案
        }
        st = append(st, i)   //比栈顶小就入栈
    }
    return
}
```
---

## C++ 预处理前后缀代码

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> pre(n), suf(n);
        pre[0] = height[0];
        for (int i = 1; i < n; i++) pre[i] = max(pre[i-1], height[i]);
        suf[n-1] = height[n-1];
        for (int i = n-2; i >= 0; i--) suf[i] = max(suf[i+1], height[i]);
        int ans = 0;
        for (int i = 0; i < n; i++) ans += min(pre[i], suf[i]) - height[i];
        return ans;
    }
};
```
---
## C++ 双指针代码
```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int n = height.size();
        int lmax = height[0], rmax = height[n-1];
        int l = 0, r = n-1;
        while (l < r) {
            lmax = max(lmax, height[l]);
            rmax = max(rmax, height[r]);
            if (lmax > rmax) {
                ans += rmax - height[r];
                r--;
            } else {
                ans += lmax - height[l];
                l++;
            }
        }
        return ans;
    }
};
```
---
## C++ 单调栈代码

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        vector<int> st;    //维护一个单调递减栈的下标
        for (int i = 0; i < (int)height.size(); i++) {
            int x = height[i];
            while (!st.empty() && height[st.back()] < x) {   //可以储水
                int r = st.back();      //获取右边界
                st.pop_back();          //出栈
                if (st.empty()) {       //栈为空了->左边没有柱子了
                    break;
                }
                int l = st.back();    //获取左边界的下标
                int h = min(height[l], x) - height[r];   //计算可以储水的高度
                int w = i - l - 1;    //计算宽度
                ans += h * w;   //加入答案
            }
            st.push_back(i);   //比栈顶小就入栈
        }
        return ans;
    }
};
```
---


## Python 预处理前后缀代码

```Python
def trap(height):
    n = len(height)
    pre = [0] * n
    suf = [0] * n
    pre[0] = height[0]
    for i in range(1, n):
        pre[i] = max(pre[i-1], height[i])
    suf[n-1] = height[n-1]
    for i in range(n-2, -1, -1):
        suf[i] = max(suf[i+1], height[i])
    ans = 0
    for i in range(n):
        ans += min(pre[i], suf[i]) - height[i]
    return ans
```
---
## Python 双指针代码
```Python
def trap(height):
    ans = 0
    n = len(height)
    lmax, rmax = height[0], height[n-1]
    l, r = 0, n-1
    while l < r:
        lmax = max(lmax, height[l])
        rmax = max(rmax, height[r])
        if lmax > rmax:
            ans += rmax - height[r]
            r -= 1
        else:
            ans += lmax - height[l]
            l += 1
    return ans
```
---
## Python 单调栈代码
```Python
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        st = []    #维护一个单调递减栈的下标
        for i, x in enumerate(height):
            while st and height[st[-1]] < x:   #可以储水
                r = st[-1]      #获取右边界
                st.pop()        #出栈
                if not st:      #栈为空了->左边没有柱子了
                    break
                l = st[-1]    #获取左边界的下标
                h = min(height[l], x) - height[r]   #计算可以储水的高度
                w = i - l - 1    #计算宽度
                ans += h * w   #加入答案
            st.append(i)   #比栈顶小就入栈
        return ans
```
---

## JavaScript 预处理前后缀代码

```JavaScript
var trap = function(height) {
    const n = height.length;
    const pre = new Array(n).fill(0);
    const suf = new Array(n).fill(0);
    pre[0] = height[0];
    for (let i = 1; i < n; i++) pre[i] = Math.max(pre[i-1], height[i]);
    suf[n-1] = height[n-1];
    for (let i = n-2; i >= 0; i--) suf[i] = Math.max(suf[i+1], height[i]);
    let ans = 0;
    for (let i = 0; i < n; i++) ans += Math.min(pre[i], suf[i]) - height[i];
    return ans;
};
```

## JavaScript 双指针代码

```JavaScript
var trap = function(height) {
    let ans = 0;
    const n = height.length;
    let lmax = height[0], rmax = height[n-1];
    let l = 0, r = n-1;
    while (l < r) {
        lmax = Math.max(lmax, height[l]);
        rmax = Math.max(rmax, height[r]);
        if (lmax > rmax) {
            ans += rmax - height[r];
            r--;
        } else {
            ans += lmax - height[l];
            l++;
        }
    }
    return ans;
};
```

## JavaScript 单调栈代码

```JavaScript
var trap = function(height) {
    let ans = 0;
    let st = [];    //维护一个单调递减栈的下标
    for (let i = 0; i < height.length; i++) {
        let x = height[i];
        while (st.length && height[st[st.length - 1]] < x) {   //可以储水
            let r = st[st.length - 1];      //获取右边界
            st.pop();                       //出栈
            if (!st.length) {               //栈为空了->左边没有柱子了
                break;
            }
            let l = st[st.length - 1];    //获取左边界的下标
            let h = Math.min(height[l], x) - height[r];   //计算可以储水的高度
            let w = i - l - 1;    //计算宽度
            ans += h * w;   //加入答案
        }
        st.push(i);   //比栈顶小就入栈
    }
    return ans;

};
```
