# [字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个字符串数组，请你将 **`字母异位词`** 组合在一起。可以按任意顺序返回结果列表。

**`字母异位词`是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。**


## 样例

- 示例 $1$:
  
    输入: `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`

    输出: `[["bat"],["nat","tan"],["ate","eat","tea"]]`

    解释：
    在 $strs$ 中没有字符串可以通过重新排列来形成 "bat"。
    字符串 $"nat"$ 和 $"tan"$ 是字母异位词，因为它们可以重新排列以形成彼此。
    字符串 $"ate" ，"eat"$ 和 $"tea"$ 是字母异位词，因为它们可以重新排列以形成彼此。

- 示例 $2$:
  
    输入: `strs = [""]`

    输出: `[[""]]`

- 示例 $3$:
  
    输入: `strs = ["a"]`

    输出: `[["a"]]`




## 数据范围
> $1 <= strs.length <= 10^4$

> $0 <= strs[i].length <= 100$




## 我的思路

**哈希表**

> 对于同一组字母异位词，我们对其进行排序后是一模一样的。所以我们可以利用哈希表来进行分组。

> 我们先创建一个哈希表，对于每一个字符串 $s$ 我们为了避免打乱原串的顺序，我们先用一个新字符串 $t$ 的来记录 $s$ 。然后对 $t$ 进行排序，然后把其当作哈希表中的 $key$ 值， $s$ 当作 $value$ 值存入到哈希表中。最后遍历每一个 $key$ ，将 $value$ 存入到答案中。

##
---

## 时间复杂度

$O(nmlogm)$ ，其中 $n$ 为 $strs$ 的长度， $m$ 为 $strs[i]$ 的长度。每个字符串排序需要 $O(mlogm)$ 的时间，有 $n$ 个字符串，所以总的时间复杂度为 $O(nmlogm)$ 。

---

## 空间复杂度

$O(nm)$

---

## Go 代码

```Go

func groupAnagrams(strs []string) [][]string {
    m := map[string][]string{}
    for _, s := range strs {
        t := []byte(s)
        sort.Slice(t, func(x, y int) bool { return t[x] < t[y] })
        ss := string(t)
        m[ss] = append(m[ss], s)
    }
    ans := make([][]string, 0, len(m))
    for _, v := range m {
        ans = append(ans,v)
    }
    return ans
}


```
---

## C++ 代码

```C++

class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> m;
        for (auto & s : strs) {
            string t = s;
            sort(t.begin(),t.end());
            m[t].push_back(s);
        }
        vector<vector<string>> ans;
        for (auto &s : m) {
            ans.push_back(s.second);
        }
        return ans;
    }
};


```
---
## Python 代码

```Python

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        m = defaultdict(list)
        for s in strs:
            key = "".join(sorted(s))   # 拼接，"".join,中间用""隔开
            m[key].append(s)
        return list(m.values())


```



## JavaScript 代码

```JavaScript

/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    const m = new Map();
    for (const s of strs) {
        const sortedS = s.split('').sort().join('');
        if (!m.has(sortedS)) {
            m.set(sortedS, []);
        }
        m.get(sortedS).push(s);
    }
    return Array.from(m.values());
};

```
