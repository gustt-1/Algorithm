# [字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)
## 题目描述 

> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。**


## 样例

- 示例 1:
    输入: `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`

    输出: `[["bat"],["nat","tan"],["ate","eat","tea"]]`

    解释：
    在 $strs$ 中没有字符串可以通过重新排列来形成 "bat"。
    字符串 $"nat"$ 和 $"tan"$ 是字母异位词，因为它们可以重新排列以形成彼此。
    字符串 $"ate" ，"eat"$ 和 $"tea"$ 是字母异位词，因为它们可以重新排列以形成彼此。

- 示例 2:
    输入: `strs = [""]`

    输出: `[[""]]`

- 示例 3:
    输入: `strs = ["a"]`

    输出: `[["a"]]`




## 数据范围
> $1 <= strs.length <= 10^4$

> $0 <= strs[i].length <= 100$




## 我的思路

**哈希表**

> 对于同一组字母异位词，我们对其进行排序后是一模一样的。所以我们可以利用哈希表来进行分组。

> 我们先创建一个哈希表，对于每一个字符串 $s$ 我们为了避免打乱原串的顺序，我们先用一个新字符串 $t$ 的来记录 $s$ 。然后对 $t$ 进行排序，然后把其当作哈希表中的 $key$ 值， $s$ 当作 $value$ 值存入到哈希表中。最后遍历每一个 $key$ ，将 $value$ 存入到答案中。

##
---

## 时间复杂度

$O(nmlogm)$ ，其中 $n$ 为 $strs$ 的长度， $m$ 为 $strs[i]$ 的长度。每个字符串排序需要 $O(mlogm)$ 的时间，有 $n$ 个字符串，所以总的时间复杂度为 $O(nmlogm)$ 。

---

## 空间复杂度

$O(nm)$

---

## Go 代码

```Go

func groupAnagrams(strs []string) [][]string {
    m := map[string][]string{}
    for _, s := range strs {
        t := []byte(s)
        sort.Slice(t, func(x, y int) bool { return t[x] < t[y] })
        ss := string(t)
        m[ss] = append(m[ss], s)
    }
    ans := make([][]string, 0, len(m))
    for _, v := range m {
        ans = append(ans,v)
    }
    return ans
}


```
---

## C++ 代码

```C++

class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> m;
        for (auto & s : strs) {
            string t = s;
            sort(t.begin(),t.end());
            m[t].push_back(s);
        }
        vector<vector<string>> ans;
        for (auto &s : m) {
            ans.push_back(s.second);
        }
        return ans;
    }
};


```
---
## Python 代码

```Python

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        m = defaultdict(list)
        for s in strs:
            key = "".join(sorted(s))   # 拼接，"".join,中间用""隔开
            m[key].append(s)
        return list(m.values())


```



## JavaScript 代码

```JavaScript

/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    const m = new Map();
    for (const s of strs) {
        const sortedS = s.split('').sort().join('');
        if (!m.has(sortedS)) {
            m.set(sortedS, []);
        }
        m.get(sortedS).push(s);
    }
    return Array.from(m.values());
};

```
