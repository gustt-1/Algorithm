# [cf2053C] [Bewitching Stargazer](https://codeforces.com/problemset/problem/2053/C)
## 题目描述 

> 鸢尾望着星空，脑海中浮现出一道美丽的难题。她邀请你来解决这个问题，相信流星雨就会形成。天空中有 n 颗星星，排成一排。艾里斯有一个望远镜，她用它来观察星星。

> 最初，艾瑞丝观测到的星星位于 [1,n]段，她的幸运值为 0 。艾瑞丝希望为她观测到的每个星段 [l,r]寻找位于中间位置的星星。因此使用了下面的递归程序：

> 首先，她将计算 m=⌊l+r2⌋ 。如果星段的长度(即 r−l+1 )是偶数，艾瑞丝将把它分成两个同样长的星段 [l,m] 和 [m+1,r] ，以便进一步观测。否则，艾瑞丝将把望远镜对准 m 号恒星，幸运值将增加 m ；随后，如果 l≠r ，艾瑞丝将继续观测两个星段 [l,m−1] 和 [m+1,r] 。艾里斯有点懒。她用整数 k 来定义自己的懒惰：随着观察的进行，她不会继续观察任何长度严格小于 k的线段 [l,r] 。在这种情况下，请预测她的最终幸运值。

> $1 \leq k \leq n \leq 2 \times 10^{9}$&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
> $1 \leq t \leq 10^{5}$

## 题目大意：
> 给你两个整数n,k。你刚开始从[1,n]（都是左闭右闭）取可以取到的中点，把它加到答案里.
> 如果是r-l+1是奇数，那么我们就可以取得一个mid,ans+=mid，并且分成区间[l,mid-1]和[mid+1,r]。

> 如果是偶数，我们只能将[l,r]分成两个区间，取不到mid，分成区间为[l,mid],[mid+1,r]。以此类推


## 我的思路
**位运算/数学**

##
> - 根据题目大意，我们容易联想到用dfs来做，从每个可以分成的区间累加，最后汇总。但是考虑到数据范围恨到，递归栈也就很大，肯定会超时。

- 1.我们只能从其他方向思考，由于答案只有当mid为奇数时才会让答案ans增加，那么我们可以从奇偶性的角度思考。
- 2.我们可以假设[1,n]范围开始找,如果n为奇数的话，那我们可以取得一个mid=(n+1)/2（这是因为n是奇数，奇数加1为偶数，偶数肯定能被2整除）所以我们可以答案ans加上mid。
  - 1.我们先特殊地假设[1,n]已经被n' = (1 + n)/2 分成了两部分。假设n'为第一次平分，如果n'依旧是奇数那么我们左右两边又可以取得两个中点，为m1,m2。可以计算得到m1+m2=(n+1),这时我们的数组就被三个中点分成了四个部分
  - 2.再特殊地假设这四个部分分出的中点都是奇数，那么我们又可以分成八个部分，也就产生了四个新的中点假设为m1,m2,m3,m4。我们可以思考，由于平分两个区间那么这两个区间肯定是关于一个中点对称的，然后每个区间又平分，又可以得到对称的两个区间。这样思考下来，也就是每一个区间都可以找到唯一的一个与他对称的区间。假如把每个中点都分组。那假设m1,m2,m2,m4是从左（1）到右（n）排列的，那我们可以得到m1+m4=(n+1),m2+m3=（n+1）。这一次平分的对答案的贡献也就是2（n+1）
  - 3.再划分又可以得到8个中点，那么这一次划分对答案的贡献也就是4（n+1）
- 3.可以发现我们对所有区间每划分一次，再都是奇数区间的情况下得到的答案贡献为2的k-1次方乘以(n+1)划分一次就是(n-1),两次是2（n-1），三次是4（n-1），四次是8（n-1）......
- 4.我们使用位运算技巧，因为是对n/2也就是n >> 1。考虑划分的数组都是对称的，奇偶性都是相同的，如果n'为奇数，那么其他的划分区间也是奇数，也就可以取得中点。那么我们也就可以用到上述所说的答案贡献技巧
- 5.考虑约束条件k，只要我们的n'的位数比k大，那么我们就是可以继续划分的。例如（二进制）n = 1101,k = 11，那么n肯定是比k大的，满足条件可继续划分。如果位长度相等(二进制)，如：n=10，k=11，那么我们需要考虑n是否比k大。如果大就可以继续划分最后一次，小就直接返回答案。 


##
---

## 时间复杂度

O(1)

---

## 空间复杂度

O(1)

---

## Go 代码

```Go

package main

import (
	"bufio"
	. "fmt"
	"io"
	"math/bits"
	"os"
)

func solve(in io.Reader, out io.Writer) {
	var t int
	Fscan(in, &t)
	for ; t > 0; t-- {
		var n, k int
		Fscan(in, &n, &k)
		m := n + 1
		ans := 0
		if n&1 > 0 { //n是奇数
			ans = m / 2
		}
		n /= 2
		if n >= k {
			d := bits.Len(uint(n)) - bits.Len(uint(k))   //取得二进制位相差的长度
			if n>>d >= k {       //比较位数相同时n,k两数大小
				d++
			}
			ans += n & (1<<d - 1) * m    //利用位运算&计算有哪些位是要乘以(n+1),位数也对应多少次幂
		}
		Fprintln(out, ans)
	}
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}



```
---

## C++ 代码

```C++






```
---
## Python 代码

```Python



```
