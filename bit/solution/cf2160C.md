# [cf1860C] [Game on Permutation](https://codeforces.com/problemset/problem/1860/C)

## 题目描述
Given a **positive** integer $x$, let $f(x)$ be the positive integer formed by reversing the binary representation of $x$ without leading zeroes. For example, if $x=12=1100_2$, then $f(x)=0011_2=3$.

You are given an integer $n$. Please determine if there exists a positive integer $x$ such that $x \oplus f(x) = n$.


---

## 题目大意
给定一个**正**整数 $x$ ，令 $f(x)$ 为通过反转不带前导零的 $x$ 二进制表示形式而形成的正整数。例如，如果 $x=12=1100_2$ ，则为 $f(x)=0011_2=3$ 。
给你一个整数 $n$ 。请确定是否存在满足 $x \oplus f(x) = n$  的正整数 $x$ 。

> $\oplus$ 表示[按位异或运算](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)。



---

## 输入

> 


## 输出

> 

---

## 我的思路

**位运算**

> https://github.com/EndlessCheng

> https://leetcode.cn/problems/minimum-number-of-flips-to-reverse-binary-string/solutions/3839577/liang-chong-fang-fa-cong-olog-n-dao-o1py-nhiq/

如果 $x$ 的最高位和最低位不同，那么异或后， $n$ 的最高位和最低位都是 $1$ 。
如果 $x$ 的最高位和最低位相同，那么异或后， $n$（补前导零，二进制长度和 $x$ 相同）的最高位和最低位都是 $0$ 。
其余镜像位置同理。
特别地，如果 x 的二进制长度是奇数，那么 $n$ 的正中间一定是 $0$ 。

反过来，如果 $n$ （可以补前导零）是二进制回文数，且（如果长度是奇数的话）正中间是 $0$ ，那么存在 $x$ 。
比如 $n=1010_2$ ，补一个前导零得到 $01010_2$ ，满足要求。
也可以去掉 $n$ 的尾零后，判断 $n$ 是否为二进制回文数，且（如果长度是奇数的话）正中间是 $0$ 。

通过计算 $n /= lowbit(n)$，可以去掉 $n$ 的尾零。
用库函数 $Reverse(n) >> LeadingZeros(n)$ 可以 O(1) 得到 $n$ 反转后的值。判断其是否等于 $n$ ，等于即说明 $n$ 是二进制回文数。



---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"math/bits"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n uint
		Fscan(in, &n)
		if n > 0 {
			n /= n & -n
		}
		m := bits.Len(n)
		if m%2 > 0 && n>>(m/2)&1 > 0 || n != bits.Reverse(n)>>bits.LeadingZeros(n) {
			Fprintln(out, "NO")
		} else {
			Fprintln(out, "YES")
		}
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript

```
