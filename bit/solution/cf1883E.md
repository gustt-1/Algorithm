# [cf1883E] [Look Back](https://codeforces.com/problemset/problem/1883/E)
## 题目描述 

> You are given an array of integers $a_1, a_2, \ldots, a_n$. You need to make it non-decreasing with the minimum number of operations. In one operation, you do the following:
-   Choose an index $1 \leq i \leq n$,
-   Set $a_i = a_i \cdot 2$.
> An array $b_1, b_2, \ldots, b_n$ is non-decreasing if $b_i \leq b_{i+1}$ for all $1 ≤ i < n.$
.

---
## 题目大意

> 给你一个整数数组 $a_1, a_2, ..., a_n$ 。你需要用最少的运算次数使数组不递减。在一次操作中，您需要执行以下操作：
- 选择索引 $1 <= i <= n$ 、
- 设置 $a_i = a_i \cdot 2$ 。
如果数组 $b_1, b_2, ..., b_n$ 中的所有 $1 <= i <= n$ 都是 $b_i<= b_{i+1}$ 则数组 $b_1, b_2, ..., b_n$ 是非递减数组。




## 输入

> 



## 输出

> 

---

## 我的思路
**位运算**

##

> 由于操作是把数字变大，第一个数肯定不用操作。如果 `a[i] <= a[i-1]`，那么 $a[i]$ 至少要操作 `(a[i-1]-1)/a[i]` 的**二进制长度次**（0 的长度是 0）才能 `>= a[i-1]`。（也可以写 for 循环计算。）
在此基础上，如果 `a[i-1]` 操作了 $p2$ 次，那么 $a[i]$ 就需要额外操作 $p2$ 次。

> 如果 `a[i] > a[i-1]`，先计算把 $a[i]$ 除 $2$ 使得 `a[i] 刚好 >= a[i-1] 的除 2 次数`，这需要 `a[i]/a[i-1]` 的**二进制长度次**，设其为 `k`。
在此基础上，如果 `a[i-1]` 操作了 `p2` 次，那么 $a[i]$ 就需要操作 `max(p2 - k, 0)` 次。


##
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"math/bits"
	"os"
)

type (
	i64  = int64
	i32  = int32
	ui64 = uint64
	ui32 = uint32
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		ans := 0
		var pre, v int
		Fscan(in, &pre)
		k := 0
		for i := 0; i < n-1; i++ {
			Fscan(in, &v)
			if v <= pre {
				k += bits.Len(uint((pre - 1) / v))
			} else {
				k = max(k-bits.Len(uint(v/pre))+1, 0)
			}
			ans += k
			pre = v
		}
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```
