# [cf1847C] [Vampiric Powers, anyone?](https://codeforces.com/problemset/problem/1847/C)
## 题目描述 

> [DIO](https://jojowiki.com/Dio_Brando) knows that the Stardust Crusaders have determined his location and will be coming to fight him. To foil their plans he decides to send out some [Stand](https://jojo.fandom.com/wiki/Stand) users to fight them. Initially, he summoned $n$ Stand users with him, the $i$\-th one having a strength of $a_i$. Using his vampiric powers, he can do the following as many times as he wishes:

-   Let the **current** number of Stand users be $m$.
-   DIO chooses an index $i$ ($1 \le i \le m$).
-   Then he summons a new Stand user, with index $m+1$ and strength given by:
    $$
    a_{m+1} = a_i \oplus a_{i+1} \oplus \ldots \oplus a_m,
    $$
    
    where the operator $\oplus$ denotes the [bitwise XOR operation](https://en.wikipedia.org/wiki/Bitwise_operation#XOR).
    
-   Now, the number of Stand users becomes $m+1$.

Unfortunately for DIO, by using Hermit Purple's divination powers, the Crusaders know that he is plotting this, and they also know the strengths of the original Stand users. Help the Crusaders find the maximum possible strength of a Stand user among all possible ways that DIO can summon.



---
## 题目大意

> 给你一个数组 $a$ ，你可以任意执行以下操作无数次（设 $m$ 为数组的长度）：
- 选择一个下标 $i$ ($1 \le i \le m$)。
- 把 $a_m$ 变成 $a_i \oplus a_{i+1} \oplus \ldots \oplus a_m$。
- 然后数组长度 $m = m + 1$ 。
> 请你输出任意操作后能得到的最大的 $a_m$ 。


## 输入

> $1 ≤ n ≤ 10^5$ , $0 ≤ a_i < 2^8$



## 输出

> 

---

## 我的思路
**位运算**

> 根据异或的性质，子数组异或和  $a_i ... a_{j-1}$ == $a_i...a_k \oplus a_j ... a_k$ ，其中 $i < j < k$ 。具体操作（证明）：先将 $a_j ... a_{k}$ 异或起来，再将结果异或上 $a_i ... a_m$ 。因为 $a_m$ = $a_j ... a_k$ ，所以 $a_i ... a_{j-1}$ = $a_i ... a_{j-1} \oplus a_j ... a_k \oplus a_m$ 。**异或性质: $a \oplus a$ = $0$**

> 根据上面的性质，我们可以知道不管如何得到的 $a_m$ 都只能是 a 中一段子数组的异或和。所以我们的目标就是找到**最大的异或和子数组**。由于 $a$ 很小，**最大**只有 $2^8$ ，所以我们可以用 $O(n^2)$ 的时间复杂度枚举当前位置的所有**前缀子数组**。



##
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		has := make([]bool, 1<<8)
		has[0] = true
		ans := 0
		cur := 0
		for _, x := range a {
			cur ^= x
			for pre := range 1 << 8 {
				if has[pre] {
					ans = max(ans, cur^pre)
				}
			}
			has[cur] = true
		}
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(a, b int) int {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}

func max64(x, y int64) int64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y int64) int64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```
