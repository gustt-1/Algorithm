# [cf1845C] [Strong Password](https://codeforces.com/problemset/problem/1845/C)
## 题目描述 

Monocarp finally got the courage to register on ForceCoders. He came up with a handle but is still thinking about the password.

He wants his password to be as strong as possible, so he came up with the following criteria:

-   the length of the password should be exactly $m$;
-   the password should only consist of digits from $0$ to $9$;
-   the password should not appear in the password database (given as a string $s$) as a **subsequence** (not necessarily contiguous).

Monocarp also came up with two strings of length $m$: $l$ and $r$, both consisting only of digits from $0$ to $9$. He wants the $i$\-th digit of his password to be between $l_i$ and $r_i$, inclusive.

Does there exist a password that fits all criteria?


---
## 题目大意

Monocarp 终于鼓起勇气在 ForceCoders 上注册。他想出了一个手柄，但仍在思考密码。

他希望他的密码尽可能强大，因此他提出了以下标准：

- 密码长度应恰好为 $m$ ；
- 密码只能包含从 $0$ 到 $9$ 的数字；
- 密码不应作为**子序列**（不一定是连续的）出现在密码数据库（以字符串 $s$ 形式给出）中。

Monocarp 还提出了两个长度为 $m$ 的字符串： $l$ 和 $r$ ，两者都只包含从 $0$ 到 $9$ 的数字。他希望密码的第 $i$ 位数字介于 $l_i$ 和 $r_i$ 之间（含这两个数字）。

是否存在符合所有条件的密码？


## 输入

> 


## 输出

> 
---

## 我的思路
**子序列自动机**

https://github.com/EndlessCheng

方法一

预处理 `s` 的 子序列自动机 `nxt` 。
密码的`第一个`数字，在 `s` 中的位置`越靠右越好`。利用 `nxt` 可以快速求出。设这个下标为 `cur`。
密码的`第二个`数字，从 `cur+1` 往右看，在 `s` 中的位置`越靠右越好`。做法同理。求出后，更新 `cur`。
如果 `cur >= n`，那么密码**可以不是** `s` 的子序列。

方法二

这个思路类似 [LC2350. 不可能得到的最短骰子序列](https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/)。
遍历 `s` 的同时，收集遇到了哪些数字。
如果收集到的数字包含 $[l[j],r[j]]$ 中的所有数字，那么此刻的 $s[i]$ 就是密码的第 $j$ 个数字。把 $j$ **加一**。
如果加一后 $j = m$ ，说明**无论怎么填，密码都是 s 的子序列**。

利用位运算，可以做到一次遍历 $+ O(1)$ 额外空间。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
// 子序列自动机
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
o:
	for Fscan(in, &T); T > 0; T-- {
		var m int
		var s, l, r string
		Fscan(in, &s, &m, &l, &r)
		n := len(s)
		nxt := make([][10]int, n+1)
		for j := range nxt[n] {
			nxt[n][j] = n
		}
		for i := n - 1; i >= 0; i-- {
			nxt[i] = nxt[i+1]
			nxt[i][s[i]-'0'] = i
		}

		cur := -1
		for i, b := range l {
			cur = slices.Max(nxt[cur+1][b-'0' : r[i]-'0'+1])
			if cur >= n {
				Fprintln(out, "YES")
				continue o
			}
		}
		Fprintln(out, "NO")
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}
```
---

## Go 代码

```Go
// 方法二
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

// https://github.com/EndlessCheng
func cf1845C(in io.Reader, out io.Writer) {
	var T, m int
	var s, l, r string
o:
	for Fscan(in, &T); T > 0; T-- {
		Fscan(in, &s, &m, &l, &r)
		vis, j := 0, 0
		for _, b := range s {
			vis |= 1 << (b - '0')
			msk := 1<<(r[j]-l[j]+1) - 1
			if vis>>(l[j]-'0')&msk == msk {
				j++
				if j == m {
					Fprintln(out, "NO")
					continue o
				}
				vis = 0
			}
		}
		Fprintln(out, "YES")
	}
}

func main() { cf1845C(bufio.NewReader(os.Stdin), os.Stdout) }
```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
