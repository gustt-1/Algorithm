# [cf1526C1] [Potions (Easy Version)](https://codeforces.com/problemset/problem/1526/C1)

## 题目描述
**This is the easy version of the problem. The only difference is that in this version $n \leq 2000$. You can make hacks only if both versions of the problem are solved.**

There are $n$ potions in a line, with potion $1$ on the far left and potion $n$ on the far right. Each potion will increase your health by $a_i$ when drunk. $a_i$ can be negative, meaning that potion will decrease will health.

You start with $0$ health and you will walk from left to right, from first potion to the last one. At each potion, you may choose to drink it or ignore it. **You must ensure that your health is always non-negative**.

What is the largest number of potions you can drink?

---

## 题目大意
> $n <= 2000$

一行中有 $n$ 个药水，最左边是 $1$ 药水，最右边是 $n$ 药水。喝醉后，每种药水都会使你的生命值增加 $a_i$ 。 $a_i$ 可以为负数，这意味着药水会降低生命值。

你从 $0$ 生命值开始，你将从左到右，从第一瓶药水走到最后一瓶。每喝一瓶药水，你都可以选择喝掉它或忽略它。 **您必须确保您的健康状况始终为非负值**。

您最多可以喝多少瓶药水？

---

## 输入

> 


## 输出

> 

---

## 我的思路

**DP**

> 设 $f[i][j]$ 为来到第 $i$ 个位置，喝了 $j$ 瓶药水。那么来到 $i$ 位置可以选择不喝，也可以选择喝。要是喝就是 $f[i][j] = f[i-1][j]$ ，直接转移就行。如果 $f[i-1][j-1] + a_i > 0$ ，那么就可以喝这瓶药水。

那么转移方程即为：  $f[i][j] = max(f[i-1][j], f[i-1][j-1] + a_i(j > 0 and f[i-1][j-1] + a_i > 0))$

最终答案即为满足 $f[i][j] > 0$ 的最大的 $j$ 。

注意初始化 $f[0][0] = 0$ ， $if (a[0] >= 0) ：f[0][1] = a[0](来到 i = 0 时，如果 a[0] > 0 那么可以喝下一瓶药水) $

 
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	//var T int
	//for Fscan(in, &T); T > 0; T-- {
	//
	//}
	var n int
	Fscan(in, &n)
	a := make([]int, n)
	for i := range a {
		Fscan(in, &a[i])
	}
	f := make([][]int, n)
	for i := range f {
		f[i] = make([]int, n+1)
		for j := range f[i] {
			f[i][j] = -inf
		}
	}
	f[0][0] = 0
	if a[0] >= 0 {
		f[0][1] = a[0] // 要初始化
	}
	for i := 1; i < n; i++ {
		for j := 0; j <= i+1; j++ {
			f[i][j] = f[i-1][j]
			if j > 0 && f[i-1][j-1] >= 0 && f[i-1][j-1]+a[i] >= 0 {
				f[i][j] = max(f[i][j], f[i-1][j-1]+a[i])
			}
		}
	}
	ans := 0
	for j := 0; j <= n; j++ {
		if f[n-1][j] >= 0 {
			ans = j
		}
	}
	Fprintln(out, ans)
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```
