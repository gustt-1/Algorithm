# [cf1984C2] [Magnitude (Hard Version)](https://codeforces.com/contest/1984/problem/C2)
## 题目描述 

> You are given an array $a$ of length $n$. Start with $c = 0$. Then, for each $i$ from $1$ to $n$ (in increasing order) do **exactly one** of the following:
  -   Option $1$: set $c$ to $c + a_i$.
  -   Option $2$: set $c$ to $|c + a_i|$, where $|x|$ is the absolute value of $x$.
> Let the maximum final value of $c$ after the procedure described above be equal to $k$. Find the number of unique procedures that result in $c = k$. Two procedures are different if at any index $i$, one procedure chose option $1$ and another chose option $2$, even if the value of $c$ is equal for both procedures after that turn.
Since the answer may be large, output it modulo $998\,244\,353$.

## 题目大意

> 给你一个长度为 $n$ 的数组 $a$ 。从 $c = 0$ 开始。然后，对从 $1$ 到 $n$ 的每个 $i$ （按递增顺序）做以下***中的一个：
- 选项 $1$ ：设置 $c$ 至 $c + a_i$ 。
- 选项 $2$ ：将 $c$ 设为 $|c + a_i|$ ，其中 $|x|$ 是 $x$ 的绝对值。
> 设上述过程后 $c$ 的最大终值等于 $k$ 。求得出 $c = k$ 的唯一程序的个数。如果在任意索引 $i$ 处，一个程序选择了选项 $1$ ，而另一个程序选择了选项 $2$ ，即使在这一轮之后两个程序的值 $c$ 都相等，那么这两个程序也是不同的。
由于答案可能很大，因此输出它的模数 $998\,244\,353$ 。





## 输入

> The first line contains a single integer $t$ ($1 \leq t \leq 10^4$) — the number of test cases.
The first line of each test case contains a single integer $n$ ($2 \leq n \leq 2 \cdot 10^5$).
The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ ($-10^9 \leq a_i \leq 10^9$).
The sum of $n$ over all test cases does not exceed $3 \cdot 10^5$.




## 输出

> For each test case, output a single integer — the number of unique procedures that result in $c = k$, modulo $998\,244\,353$.


---

## 我的思路
**前缀和/贪心**


> 题目意思即对于每一个数 $a_i$ ,总和 $s$ ，加上后可以选择加绝对值也可以不加绝对值。我们考虑前缀和，即来到 $i$ 位置的 $s[i]$ ，如果假如 $i$ 位置的值后仍然是正数，那么加不加绝对值都一样（正数的绝对值还是正数），所以对答案 $ans$ 的贡献多了一倍即 $ans*2$ （乘法原理）。我们可以在求累加和时就处理 $ans$。

> 我们先求一次前缀和 $s[i]$ ，然后我们用 $mins$ 记录每个位置累加和的最小值。如果 $mins$ 是大于零的，说明每一次我们累加都可以有两种选择，由于我们一开始就累加了答案 $ans$ 我们就直接返回就行了。

> 如果 $mins$ 和多个位置前缀和小于零呢？由于我们可以选择取绝对值，那么我们该何时取一个绝对值？贪心地认为，我们在 $mins$ 取绝对值是最优的，因为我们的负数越小，取绝对值就越大。如果每次遇到前缀和小于零就取绝对值会更大吗？是不会的。我们就假设来到一个位置时，当前前缀和为 $-2$ 我们取一个绝对值得到 $2$，如果下一个位置数组值为 $-3$ 我们累加到前缀和得到 $-1$，取绝对值得到 $1$ ，那其实不如等到前缀和变成 $-5$ 再取绝对值更优。

> 所以当我们遇到 $mins$ 取绝对值最优。进一步思考如果假设 $s[i] == mins$ ，那么我们在这里选择翻正，那么我们后续的 $s[i]$ 是在原数组不做翻正操作的，我们选择反正后，后续的 $s[i]<0$ 都会使得 $s[i]>=0$ 因为我们在 $mins$ 翻正，后面的负数都不会使得翻正后的前缀和缩减之小于零。我们从后往前开始统计，初始化 $neg=1$ ，只要 $s[i] < 0$ 我们就 $neg = neg*2%mod$ ，一旦我们 $s[i] == mins$ 我们就把 $neg$ 加入到 $sumneg$ 里。

> 最后答案即是 $ans * sumneg$ （记得取模）。


---

## 时间复杂度

$O(n)$

---

## 空间复杂度

$O(n)$


---

## Go 代码

```Go

package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
)

type (
	i64 = int64
	i32 = int32
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		s := make([]int, n+1)
		ans := 1
		const mod = 998244353
		for i := 1; i <= n; i++ {
			Fscan(in, &s[i])
			s[i] += s[i-1]
			if s[i] >= 0 {
				ans = ans * 2 % mod
			}
		}
		mins := slices.Min(s)
		if mins >= 0 {
			Fprintln(out, ans)
			continue
		}
		neg := 1
		sumneg := 0
		for i := n; i > 0; i-- {
			if s[i] == mins {
				sumneg = (sumneg + neg) % mod
			}
			if s[i] < 0 {
				neg = neg * 2 % mod
			}
		}
		Fprintln(out, ans%mod*sumneg%mod)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}


```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python




```
