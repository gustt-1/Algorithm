# [cf2008E] [Alternating String](https://codeforces.com/contest/2008/problem/E)
## 题目描述 

> Sakurako really loves alternating strings. She calls a string $s$ of lowercase Latin letters an alternating string if characters in the even positions are the same, if characters in the odd positions are the same, and the length of the string is **even**.
For example, the strings 'abab' and 'gg' are alternating, while the strings 'aba' and 'ggwp' are not.
As a good friend, you decided to gift such a string, but you couldn't find one. Luckily, you can perform two types of operations on the string:
1.  Choose an index $i$ and delete the $i$\-th character from the string, which will reduce the length of the string by $1$. This type of operation can be performed **no more than $1$ time**;
2.  Choose an index $i$ and replace $s_i$ with any other letter.
Since you are in a hurry, you need to determine the minimum number of operations required to make the string an alternating one.



> 樱子非常喜欢交替字符串。如果偶数位置上的字符相同，奇数位置上的字符相同，并且字符串的长度是**偶数**，她就会把由小写拉丁字母组成的字符串 $s$ 称为交替字符串。
例如，字符串 "abab "和 "gg "是交替字符串，而字符串 "aba "和 "ggwp "则不是。
作为好朋友，您决定赠送这样的字符串，但您找不到。幸运的是，您可以对字符串进行两种操作：
1.  选择索引 $i$ ，删除字符串中的 $i$ 字符，这样字符串的长度就会减少 $1$ 。此类操作的次数不超过 $1$ 次；
2.  选择索引 $i$ 并用其他字母替换 $s_i$ 。
由于时间紧迫，您需要确定使字符串成为交替字符串所需的最少操作次数。





## 输入

> The first line contains a single integer $t$ ($1 \le t \le 10^4$)  — the number of test cases.
The first line of each test case contains a single number $n$ ($1 \le n\le 2\cdot 10^5$)  — the length of the string.
The second line of each test case contains a string $s$, consisting of lowercase Latin letters.
It is guaranteed that the sum of $n$ across all test cases does not exceed $2 \cdot 10^5$.




## 输出

> For each test case, output a single integer — the minimum number of operations required to turn the string $s$ into an alternating one.


---

## 我的思路
**前缀和**


> 要每个奇数位相同，偶数位也相同，那么我们最优的即是让奇数位最多的字母替换其他奇数位，偶数位同理。题目要求字符串长度必须为偶数，并且只能做一次删除，那么如果原始字符串为奇数我们必须做一次删除，偶数的话就不能删除。我们用一个二维数组（第一个维度用来存储位置的奇偶性，另一个用来存每个字母）来存储当前数位以及字母地出现频次。
  - 如果是偶数那么就只需要顺序统计一次然后取出奇偶位上最多的 $m1, m2$ 然后答案即是 $n-m1-m2$ 。
  - 如果是奇数我们就对于每个位置 $i$ 都求前缀和后缀最多（即当前位置作为要删除的，然后每次都记录一次答案）


---

## 时间复杂度

$O(n)$

---

## 空间复杂度

$O(n)$


---

## Go 代码

```Go

package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
)

type (
	i64 = int64
	i32 = int32
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		var s string
		Fscan(in, &s)
		suf := [2][26]int{}
		for i, ss := range s {
			suf[i%2][ss-'a']++
		}
		if n%2 == 0 {
			Fprintln(out, n-slices.Max(suf[0][:])-slices.Max(suf[1][:]))
			continue
		}
		mx := 0
		pre := [2][26]int{}
		for i, ss := range s {
			suf[i%2][ss-'a']--
			m1, m2 := 0, 0
			for j := 0; j < 26; j++ {
				m1 = max(m1, suf[0][j]+pre[1][j])
				m2 = max(m2, suf[1][j]+pre[0][j])
			}
			mx = max(mx, m1+m2)
			pre[i%2][ss-'a']++
		}
		Fprintln(out, n-mx)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}



```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python




```
