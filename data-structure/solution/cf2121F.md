# [cf2112F] [Yamakasi](https://codeforces.com/problemset/problem/2121/F)
## 题目描述 

> You are given an array of integers $a_1, a_2, \ldots, a_n$ and two integers $s$ and $x$. Count the number of subsegments of the array whose sum of elements equals $s$ and whose maximum value equals $x$.
More formally, count the number of pairs $1 \leq l \leq r \leq n$ such that:
-   $a_l + a_{l + 1} + \ldots + a_r = s$.
-   $\max(a_l, a_{l + 1}, \ldots, a_r) = x$.

> 给你一个由整数 $a_1, a_2, \ldots, a_n$ 和两个整数 $s$ 及 $x$ 组成的数组。请计算元素之和等于 $s$ 且最大值等于 $x$ 的数组子段的数目。
更具体地说，计算有多少对 $1 \leq l \leq r \leq n$ 这样的数组：
- $a_l + a_{l + 1} + \ldots + a_r = s$  
- $\max(a_l, a_{l + 1}, \ldots, a_r) = x$






---

## 我的思路
**前缀和+哈希表**

##

> 题目求一个子数组中（和为s，最大值为x）。我们可以利用前缀和求的子数组的和total。total = sum[l+r] - sum[l]。我们可以利用哈希表来统计合法的左端点出现的次数，用init来记录预处理的前缀和。

- 1.我们用一个total来表示从1-i的所有总和，cnt来统计总和的次数，init来预处理前缀和。
- 2.我们就不开一个数组了，直接在循环里输入val来表示第i个数的值。
- 3.先来判断合法性，如果val > x说明我们前面预处理的前缀和init和统计的次数cnt都是无效的，我们直接清空就行。
- 4.接着我们就将来到的位置的前缀和total加入到预处理init中
- 5.接下来我们判断val == x，说明我们在子数组中找到了一个值等于x，符合题意。那么我们就预处理的前缀和加入到正式的统计cnt中去。
- 6.total += val,我们再看我们之前统计的前缀和有没有total-s，如果有就将符合答案的左端点个数加入到答案

##
---

## 时间复杂度

O(n)

---

## 空间复杂度

O()


---

## Go 代码

```Go

package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

func solve(in io.Reader, out io.Writer) {
	var t int
	Fscan(in, &t)
	for ; t > 0; t-- {
		var n, s, x int
		Fscan(in, &n, &s, &x)
		cnt := map[int]int{}
		init := []int{}
		total := 0
		ans := 0
		for i := 0; i < n; i++ {
			var val int
			Fscan(in, &val)
			if val > x {
				cnt = map[int]int{}
				init = init[:0]
				continue
			}
			init = append(init, total)
			if val == x {
				for _, i := range init {
					cnt[i]++
				}
				init = init[:0]
			}
			total += val
			ans += cnt[total-s]
		}
		Fprintln(out, ans)
	}
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}




```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python




```
