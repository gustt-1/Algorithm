# [cf2165A] [Cyclic Merging](https://codeforces.com/problemset/problem/2165/A)

## 题目描述
You are given $n$ non-negative integers $a_1,a_2,\ldots,a_n$ arranged on a ring. For each $1\le i< n$, $a_i$ and $a_{i+1}$ are adjacent; $a_1$ and $a_n$ are adjacent.

You need to perform the following operation **exactly** $n-1$ times:

-   Choose any pair of adjacent elements on the ring, let their values be $x$ and $y$, and merge them into a single element of value $\max(x,y)$ with cost $\max(x,y)$.

Note that this operation will decrease the size of the ring by $1$ and update the adjacent relationships accordingly.

Please calculate the minimum total cost to merge the ring into one element.


---

## 题目大意
给你一个 **环形数组** ，你可以任意选择两个相邻的元素，将它们**合并成** $max(x, y)$ ，合并的代价为 $max(x, y)$ 。
你需要合并 $n-1$ 次，使得数组**只剩下一个**元素。
请你计算出**最小的**合并代价。


---

## 输入




## 输出

> 

---

## 我的思路

**贪心**

> 不难发现，合并的最优是邻居合并，因为**合并操作**一定是**单调不减**的，对于任意一个元素的左右邻居，**邻居都不可能减小**，所以合并邻居的代价一定是最小的。那么如何进行合并呢？

> 假设当前合并的元素为 $a_i$ ，左边离 $i$ 最近大于 $a_i$ 的元素为 $a_j$ 。那么中间的元素一定是比 $a_i$ 小的，不管怎么样，中间的一堆元素最终都是最优和 $a_i$ 合并的。即 $a_{i-1} < a_i$ ，那么最终代价是 $a_i$ ，中间一堆元素也是刚刚的一个子问题，那么可以推出**当前位置**  $i$ 对答案的贡献即为 $max(a_i, a_{i+1})$ ，由于是**环形**的，还要考虑到 $max(a_{n-1}, a_0)$ 。并且我们一定是要操作 $n - 1$ 次，但是对于最大的那个元素一定是算了两次的，我们遇到**最大的元素**时，最优是把**剩余元素**合并起来，然后**最后一次**再跟**最大元素**合并，所以最终答案要**减去** $max(a_0, a_1, a_2, ... , a_{n-1})$

> 最终答案即为 $sum(max(a_0, a_1), max(a_1, a_2), ..., max(a_{n-2}, a_{n-1})) + max(a_{n-1}, a_0) - max(a_0, a_1, a_2, ... , a_{n-1})$


---

## 时间复杂度

$O(n)$ 

---

## 空间复杂度

$O(1)$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	const mod = 998244353
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		ans := 0
		for i := 0; i < n-1; i++ {
			ans += max(a[i], a[i+1])
		}
		Fprintln(out, ans+max(a[n-1], a[0])-slices.Max(a))
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```

---

## JavaScript 代码

```JavaScript
```
