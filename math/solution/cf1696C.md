# [cf1696C] [Fishingprince Plays With Array](https://codeforces.com/problemset/problem/1696/C)

## 题目描述
Fishingprince is playing with an array $[a_1,a_2,\dots,a_n]$. He also has a magic number $m$.

He can do the following two operations on it:

-   Select $1\le i\le n$ such that $a_i$ is divisible by $m$ (that is, there exists an integer $t$ such that $m \cdot t = a_i$). Replace $a_i$ with **$m$ copies** of $\frac{a_i}{m}$. The order of the other elements doesn't change. For example, when $m=2$ and $a=[2,3]$ and $i=1$, $a$ changes into $[1,1,3]$.
-   Select $1\le i\le n-m+1$ such that $a_i=a_{i+1}=\dots=a_{i+m-1}$. Replace these $m$ elements with **a single** $m \cdot a_i$. The order of the other elements doesn't change. For example, when $m=2$ and $a=[3,2,2,3]$ and $i=2$, $a$ changes into $[3,4,3]$.

Note that the array length might change during the process. The value of $n$ above is defined as the current length of the array (might differ from the $n$ in the input).

Fishingprince has another array $[b_1,b_2,\dots,b_k]$. Please determine if he can turn $a$ into $b$ using any number (possibly zero) of operations.



---

## 题目大意
给你一个数组 $a$ 和一个数组 $b$ ，判断是否可以通过 $a$ 进行一系列操作变成 $b$ 。

> 操作一：选择 $a_i$ ，若 $a_i$ 能够整除 m ，则将 $a_i$ 替换为 $m$ 个 $\frac{a_i}{m}$ 。

> 操作二：选择 $a_i,a_{i+1},\dots,a_{i+m-1}$ ，若这 $m$ 个元素相等，则将这 $m$ 个元素替换为 $m \cdot a_i$ 。



---

## 输入




## 输出

> 

---

## 我的思路

**归一化思想/寻找最简等价形态**

> 我们发现操作一和操作二是可逆的，类似于积分和微分的关系，也就是我们可以将 $a$ 转换为 $b$ ，也可以将 $b$ 转换为 $a$ 。为了判断是否可以将 $a$ 转换为 $b$ ，我们可以将 $a$ 转换为最简等价形态，然后判断是否与 $b$ 相等。

### 具体操作如下：

**定义一个结构体 `pair` ，表示数组中的一个元素。结构体中包含两个字段：`v` 表示元素的值，`c` 表示元素的出现次数。**

> 可以封装一个函数，将 $a, b$ 两个数组转换为**最简等价形态**。遍历数组，对于每个元素 $x$ ，如果 $x$ 能够整除 $m$ ，则将 $x$ 替换为 $m$ 个 $\frac{x}{m}$ 。只要 $x$ 能够被 $m$ **整除**，就**一直进行操作一**，直到 $x$ 不能被 $m$ 整除。每次操作我们都将 $cnt *= m$ 。最终 $v$ 为 $x$ 除去 $m$ 这个因子的数。如果当前数和**前一个数相等**（即 $res[len(res)-1] == x$ ），那么将 $res[len(res)-1].c += cnt$ 。否则就 $append(pair$ { $x, cnt$ } $)$ 。

> 最后遍历两个数组转化为**最简等价形态**，可以先判断两个数组的长度是否相等。如果不相等，那么 $a$ 不能转换为 $b$ 。否则就接着判断**每个** $i$ 位置的 $fa[i].v$ 是否等于 $fb[i].v$ ，以及 $fa[i].c$ 是否等于 $fb[i].c$ 。如果都相等，那么 $a$ 可以转换为 $b$ 。否则 $a$ 不能转换为 $b$ 。


---

## 时间复杂度

$O()$ 

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	type pair struct {
		v, c int
	}
	for Fscan(in, &T); T > 0; T-- {
		var n, m, k int
		Fscan(in, &n, &m)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		Fscan(in, &k)
		b := make([]int, k)
		for i := range b {
			Fscan(in, &b[i])
		}
		f := func(arr []int) (res []pair) {
			for _, x := range arr {
				cnt := 1
				for x%m == 0 {
					x /= m
					cnt *= m
				}
				if len(res) > 0 && res[len(res)-1].v == x {
					res[len(res)-1].c += cnt
				} else {
					res = append(res, pair{x, cnt})
				}
			}
			return
		}
		fa, fb := f(a), f(b)
		if len(fa) != len(fb) {
			Fprintln(out, "NO")
			goto next
		} else {
			for i := range fa {
				if fa[i].v != fb[i].v || fa[i].c != fb[i].c {
					Fprintln(out, "NO")
					goto next
				}
			}
		}
		Fprintln(out, "YES")
	next:
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(a, b int) int {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}

func max64(x, y int64) int64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y int64) int64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}
```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```

---

## JavaScript 代码

```JavaScript

```
