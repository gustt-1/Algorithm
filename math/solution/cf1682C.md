# [cf1682C] [LIS or Reverse LIS?](https://codeforces.com/problemset/problem/1682/C)

## 题目描述
You are given an array $a$ of $n$ positive integers.

Let $\text{LIS}(a)$ denote the length of [longest strictly increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of $a$. For example,

-   $\text{LIS}([2, \underline{1}, 1, \underline{3}])$ = $2$.
-   $\text{LIS}([\underline{3}, \underline{5}, \underline{10}, \underline{20}])$ = $4$.
-   $\text{LIS}([3, \underline{1}, \underline{2}, \underline{4}])$ = $3$.

We define array $a'$ as the array obtained after reversing the array $a$ i.e. $a' = [a_n, a_{n-1}, \ldots , a_1]$.

The beauty of array $a$ is defined as $min(\text{LIS}(a),\text{LIS}(a'))$.

Your task is to determine the maximum possible beauty of the array $a$ if you can rearrange the array $a$ arbitrarily.


---

## 题目大意
给你一个数组 $a$ ，你可以将它**重新排列成任意顺序**。

你需要最大化数组 $a$ 的美丽值。

数组 $a$ 的美丽值定义为 $min(LIS(a), LIS(a'))$ ，其中 $LIS(a)$ 表示数组 $a$ 的**最长严格递增子序列的长度**，$LIS(a')$ 表示数组 $a$ 的**反转数组** $a'$ 的最长严格递增子序列的长度。

你需要输出**最大**的美丽值。



---

## 输入




## 输出

> 

---

## 我的思路

**贡献法**

> 从贡献的角度出发，我们统计数组 $a$ 中出现次数大于等于 $2$ 的元素的个数，设为 $double$。因为是严格递增子序列，所以 $double$ 个元素可以分配给两种最长自增子序列。对于答案 $min(LIS(a), LIS(a'))$ 稳定是 1 ，而对于单个的元素，只能排列分配给一种，所以可以看作是 $0.5$ 。例如 $a = [1,2]$ ，两个都是单个元素，所以答案是 $(0.5+0.5+1)/2 = 1$ （上取整）

---

## 时间复杂度

$O()$ 

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		a := make([]int, n)
		cnt := map[int]int{}
		double := 0
		for i := range a {
			Fscan(in, &a[i])
			cnt[a[i]]++
		}
		for _, x := range cnt {
			if x > 1 {
				double++
			}
		}
		Fprintln(out, double+(len(cnt)-double+1)/2)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(a, b int) int {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}

func max64(x, y int64) int64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y int64) int64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```