# [cf2157C] [Meximum Array 2](https://codeforces.com/problemset/problem/2157/C)

## 题目描述
You are given three positive integers $n$, $k$, and $q$. You are also given $q$ tuples $(c, l, r)$, with $1 \leq c \leq 2$ and $1 \leq l \leq r \leq n$.

An array $a_1, a_2, \ldots, a_n$ is **meximum** if $0 \leq a_i \leq 10^9$ for each $i$ in $[1, n]$, and for each given tuple $(c, l, r)$,

-   if $c = 1$, then $\min(a_l, a_{l+1}, \ldots, a_r) = k$;
-   if $c = 2$, then $\operatorname{MEX}$$^{\text{∗}}$$(a_l, a_{l+1}, \ldots, a_r) = k$.

Note that the parameter $k$ is the same for all the conditions.

Find a **meximum** array $a_1, a_2, \ldots, a_n$ of length $n$. The input is generated in such a way that a valid array always exists. If there are multiple possible arrays, you can print any one of them.

---

## 题目大意
给你三个数 $n$, $k$, 和 $q$。你也给你 $q$ 个元组 $(c, l, r)$，其中 $1 \leq c \leq 2$ 和 $1 \leq l \leq r \leq n$。

请你构造一个长度为 $n$ 的数组，其中数组必须满足 $q$ 个条件。

如果 $c == 1$ ，则要求 $a_l, a_{l+1}, \ldots, a_r$ 中的最小值为 $k$。

如果 $c == 2$ ，则要求 $a_l, a_{l+1}, \ldots, a_r$ 的 $MEX$ 为 $k$。

---

## 输入



## 输出

> 

---

## 我的思路

**贪心/思维**

> 对于 $c == 1$（区间 $1$ ） 时，区间内**最小值**必须为 $k$ ，为了方便处理，我们可以将区间内的所有元素都设置为 $k$ 。

> 对于 $c == 2$（区间 $2$ ） 时，区间内的 $MEX$ 必须为 $k$ ，为了方便处理，我们可以将区间内的所有元素都设置为 $1$ （先做个标记） 。后续再处理区间其他的元素

> 对于**即在**`区间 1` ，**也在**`区间 2` 的元素，我们最开设置的 $a_i = k$ 是**无效的**。
`约束1`：因为 $MEX$ 是`不能出现` $k$ 的。所以我们必须得将这个数设置为 `< k` 或者 `> k` ，`约束2`：由于 $a_i$ 在区间 $1$ ，**最小的数**必须为 $k$ ，所以只能将其设置为 `> k` 。同样为了方便处理我们可以直接将其设置为 $k + 1$ 。

> 对于其他位置的元素。因为我们要满足 $MEX$ 为 $k$ ，所以我们必须从 $0$ 开始以直到 $k - 1$ 都必须有数，那么我们可以将这些数的下标对 $k$ 进行**求余**，那么就一定满足我们可以覆盖 `0 ~ (k-1)` 这些数 


---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, k, q int
		Fscan(in, &n, &k, &q)
		var c, l, r int
		a := make([]int, n)
		b := make([]int, n)
		for range q {
			Fscan(in, &c, &l, &r)
			l--
			if c == 1 {
				for i := range a[l:r] {
					a[i+l] = k
				}
			} else {
				for i := range b[l:r] {
					b[i+l] = 1
				}
			}
		}
		for i := range n {
			if a[i] == k && b[i] == 1 {
				a[i] = k + 1
			} else if a[i] == 0 {
				a[i] = i % k
			}
		}
		for _, x := range a {
			Fprint(out, x, " ")
		}
		Fprintln(out)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}
```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```
