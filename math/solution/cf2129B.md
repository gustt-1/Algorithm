# [cf2129B] [Stay or Mirror](https://codeforces.com/problemset/problem/2129/B)
## 题目描述 

> 给定一个长度为 `n` 的排列组合 `p1, p2, …, pn`，我们需要用如下方法构造一个新的数组 `a1, a2, …, an`：对于每个 `1 ≤ i ≤ n`，可以选择将 `ai` 设置为 `pi`，或者设置为 `2n − pi`。要求计算出在所有可能构造方式中，数组 `a1, a2, …, an` 的**最小逆序对数**。  
这里，长度为 `n` 的排列是由 `n` 个不同的整数组成的数组，这些整数取自 `1` 到 `n`，且每个整数恰好出现一次。例如 `[2, 3, 1, 5, 4]` 是一个排列，而 `[1, 2, 2]` 不是（因为数字 2 出现了两次），`[1, 3, 4]` 也不是（因为 `n = 3`，但数组中出现了 4）。  
在数组 `a1, a2, …, an` 中，**逆序对**定义为一对索引 `(i, j)`，满足 `1 ≤ i < j ≤ n` 且 `ai > aj`。

## 输入

> 每个测试包含多个测试用例。第一行包含测试用例的数量 `t`，满足 $1 \le t \le 10^3$。每个测试用例说明如下：每个测试用例的第一行包含一个整数 `n`，满足 $2 \le n \le 5 \cdot 10^3$。每个测试用例的第二行包含 $n$ 个整数 $p_1, p_2, \dots, p_n$，满足 $1 \le p_i \le n$，且保证 $(p_1, p_2, \dots, p_n)$ 是一个排列。保证所有测试用例中 `n` 的总和不超过 $5 \cdot 10^3$。



---

## 我的思路
**贪心**

##

- 特殊地
  - 考虑pi=1，对于所有数都没有进行转化（即没有变成2n - pi）。因为pi=1是整个数组中最小的数，所以前面就有i-1个数是大于pi=1的，也就产生了i-1个逆序对。如果pi进行转换，也就成了2n-1，这是整个数组中最大的数，那么对于i的右边，也就形成了n-i个逆序对，那么我们只需要取min(i-1,n-i)。我们再把1从整个数组中删除，那么子问题就变成了考虑pi=2，跟考虑pi=1是同样的问题。
- 一般地
  - 我们就从数组中第一个位置开始枚举，假如ai=pi，那么就找左边pi比ai大的形成逆序对；假如ai'=2n-pi，就从右边找比还是pi比ai大的（因为转化就是2n-pi和2n-ai，如果ai < pi，那么ai' > pi'）
  - 遍历过程中使用l,r来记录左边和右边形成的逆序对个数，我们选择较小的一边
  - 但是统计的时候会不会重复统计呢，因为我们每个数都有两种选择（pi/2n - pi即要么不变，要么变大）。我们再特殊地考虑....4....2....（n > 4,逆序对是相互的）
	- 假设4统计l，更小（选择左边）那么我们的4就不变，那么也就不会考虑到2。那么对于2,我们统计左边的会把答案加1，统计右边也就不会考虑到4（答案加了一）
    - 假设4选择r，那么四就会变大，考虑右边比4大的，2 < 4,不会记录答案。对于2，假设考虑2考虑左边，4比2更大，答案加1，统计右边也不会考虑到4（答案加了一）
	- 可以看到，由于(4,2)是一个逆序对，不管4,2怎么变化，一定会有一个逆序对，但是无论怎么变化我们都没有重复统计（大于1）


##
---

## 时间复杂度

O(n方)

---

## 空间复杂度

O()

---

## Go 代码

```Go

package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

func solve(in io.Reader, out io.Writer) {
	var t int
	Fscan(in, &t)
	for ; t > 0; t-- {
		ans := 0
		var n int
		Fscan(in, &n)
		p := make([]int, n)
		for i := 0; i < n; i++ {
			Fscan(in, &p[i])
		}

		for i := 0; i < n; i++ {
			l := 0
			r := 0
			for _, ll := range p[:i] {
				if ll > p[i] {
					l++
				}
			}
			for _, rr := range p[i+1:] {
				if rr > p[i] {
					r++
				}
			}
			ans += min(l, r)
		}
		Fprintln(out, ans)
	}
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}



```
---

## C++ 代码

```C++

#include<bits/stdc++.h>

using namespace std;

void solve() {
    int n; cin >> n;
    vector<int> p(n);
    for (auto &x : p) cin >> x;
    int ans = 0;
    for (int i = 0; i < n; i++) {
        int l = 0, r = 0;
        for (int j = 0; j < i; j++) {
            if (p[j] > p[i]){
                l++;
            }
        }
        for (int j = i + 1; j < n; j++) {
            if (p[j] > p[i]) {
                r++;
            }
        }
        ans += min(l,r);
    }
    cout << ans << endl;
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);

    int t; cin >> t;
    while(t--) solve();

    return 0;
}


```
---
## Python 代码

```Python



```
