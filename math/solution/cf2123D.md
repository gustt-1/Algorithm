# [cf2123D] [Binary String Battle](https://codeforces.com/contest/2123/problem/D)

## 题目描述
Alice and Bob are given a binary string $s$ of length $n$, and an integer $k$ ($1\leq k < n$).

Alice wins if she is able to transform all characters of $s$ into zeroes. If Alice is unable to win in a finite number of moves, then Bob wins.

Alice and Bob take turns, with Alice going first.

-   On Alice's turn, she may choose any **subsequence**$^{\text{∗}}$ of length $k$ in $s$, then set all characters in that subsequence to zero.
-   On Bob's turn, he may choose any **substring**$^{\text{†}}$ of length $k$ in $s$, then set all characters in that substring to one.

Note that Alice wins if the string consists of all zeros at any point during the game, including in between Alice's and Bob's turns.

Determine who wins with optimal play.


## 题目大意

给你一个长度为 `n` 的字符串 `s` ，和一个整数 `k` 。  $Alice$ 和 $Bob$ 轮流操作， $Alice$ 先操作。 $Alice$ 可以选择任意长度为 `k` 的子序列，将其中的所有字符变成 `0` 。 $Bob$ 可以选择任意长度为 `k` 的子字符串，将其中的所有字符变成 `1` 。如果在任意时刻，字符串中所有字符都变成了 `0` ，那么 $Alice$ 就赢了。否则 $Bob$ 赢了。


---


## 输入

>


## 输出

>

---

## 我的思路
**思维/贪心**

> 如果初始 $1$ 的数量就`小于等于` `k` ，那么 $Alice$ 可以直接将所有的 `1` 都变成 `0` ，那么 $Alice$ 胜出。

> 如果`大于` $k$ ，那么对于 $Bob$ 来说，必须操作后 $1$ 的数量一定要 `大于` $k$ ，否则 $Alice$ 就可以在 $Bob$ 操作前将所有的 $1$ 都变成 $0$ ，那么 $Alice$ 胜出。所以 $Bob$ 最优的决策是利用多余的 $1$ 构造使得操作后 $1$ 的数量`大于` $k$ 。对于 $Bob$ 来说尽可能使得选择的子数组 $1$ `重叠的少`。例如：`1, 1, 1, 1, 1, 1` $(k = 4)$  。对于 $Alice$ 来说要尽使得 $1$ 分散，那么可以操作后 `0, 0, 1, 1, 0, 0` 那么 $Bob$ `一定会重叠两个`，那么操作后 $1$ 的数量一定是 $4$ ，那么 $Alice$ 获胜。

> 可以的出 $Bob$ 最优一定是将`最左端或者最右端`变成 $1$ ， $Alice$ 就是尽可能让左右端变成 $0$ 。那么可以得出，如果 $k$ `小于等于数组长度一半`，那么 $Bob$ 就可以`一直选择`最左端或者最右端连续变成 $1$ ，那么 $Alice$ 一定无法获胜，否则可以参考上面的样例的方式来获胜。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, k int
		Fscan(in, &n, &k)
		var s string
		Fscan(in, &s)
		one := 0
		for _, x := range s {
			if x == '1' {
				one++
			}
		}
		if one <= k || k*2 > n {
			Fprintln(out, "Alice")
		} else {
			Fprintln(out, "Bob")
		}
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
