# [cf2055C] [The Trail](https://codeforces.com/problemset/problem/2055/C)

## 题目描述
| There are no mountains in Florida, and Florida Man cannot comprehend their existence. As such, he really needs your help with this one. |
|  ---  |

In the wilderness lies a region of mountainous terrain represented as a rectangular grid with $n$ rows and $m$ columns. Each cell in the grid is identified by its position $(i, j)$, where $i$ is the row index and $j$ is the column index. The altitude of cell $(i, j)$ is denoted by $a_{i,j}$.

However, this region has been tampered with. A path consisting of $n + m - 1$ cells, starting from the top-left corner $(1, 1)$ and ending at the bottom-right corner $(n, m)$, has been cleared. For every cell $(i, j)$ along this path, the altitude $a_{i,j}$ has been set to $0$. The path moves strictly via downward ($\mathtt{D}$) or rightward ($\mathtt{R}$) steps.

To restore the terrain to its original state, it is known that the region possessed a magical property before it was tampered with: all rows and all columns shared the same sum of altitudes. More formally, there exists an integer $x$ such that $\sum_{j=1}^m a_{i, j} = x$ for all $1\le i\le n$, and $\sum_{i=1}^n a_{i, j} = x$ for all $1\le j\le m$.

Your task is to assign new altitudes to the cells on the path such that the above magical property is restored. It can be proven that a solution always exists. If there are multiple solutions that satisfy the property, any one of them may be provided.



---

## 题目大意
给你一个 $n * m$ 的网格图 $g$ 代表一个山， $g_{ij}$ 代表 $(i, j)$ 这个点的海拔高度。另外给你一个长度为 $n + m - 1$ 字符串 $s$ 代表一个路径，路径上的每个字符都是 $D$ 或 $R$，分别代表向下走或向右走。路径上的高度都是 0 ，路径从 $(0, 0)$ 到 $(n-1, m-1)$ ，并且路径上的高度为 0 。

你需要重新设置路径上的高度，使得所有行和所有列的高度和都等于 $x$ ，即所有行和所有列的高度和都相等。

---

## 输入




## 输出

> 

---

## 我的思路

**构造**

> 我们假设每个行，列的高度都为 $S$ ，根据要求那么 $n * S = m * S$ 。如果 $n != m$ 那么要满足要求的话只能将 $S$ 置为 $0$ 。为了方便，我们将 $n == m$ 也考虑 $S = 0$ 。

> 如何确定 $S$ 呢？如果对于路径上的一个点为 $'D'$ ，那么它是向下移动的，所以以后都不会回到当前行了，那么这个行就已经确定了，我们只需要将这个行的高度累加起来即可，当前点设置为和的**相反数**即可，如果为 $'R'$ 同理。



---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, m int
		Fscan(in, &n, &m)
		var dis string
		Fscan(in, &dis)
		grid := make([][]int, n)
		for i := range grid {
			grid[i] = make([]int, m)
			for j := range grid[i] {
				Fscan(in, &grid[i][j])
			}
		}
		i, j := 0, 0
		for i+j < n+m-1 {
			if i+j == n+m-2 || dis[i+j] == 'D' {
				res := 0
				for k := range m {
					res -= grid[i][k]
				}
				grid[i][j] = res
				i++
			} else {
				res := 0
				for k := range n {
					res -= grid[k][j]
				}
				grid[i][j] = res
				j++
			}
		}
		for _, row := range grid {
			for _, val := range row {
				Fprint(out, val, " ")
			}
			Fprintln(out)
		}
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```
