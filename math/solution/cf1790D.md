# [cf1790D] [Matryoshkas](https://codeforces.com/problemset/problem/1790/D)

## 题目描述
Matryoshka is a wooden toy in the form of a painted doll, inside which you can put a similar doll of a smaller size.

A set of nesting dolls contains one or more nesting dolls, their sizes are consecutive positive integers. Thus, a set of nesting dolls is described by two numbers: $s$ — the size of a smallest nesting doll in a set and $m$ — the number of dolls in a set. In other words, the set contains sizes of $s, s + 1, \dots, s + m - 1$ for some integer $s$ and $m$ ($s,m > 0$).

You had one or more sets of nesting dolls. Recently, you found that someone mixed all your sets in one and recorded a sequence of doll sizes — integers $a_1, a_2, \dots, a_n$.

You do not remember how many sets you had, so you want to find the **minimum** number of sets that you could initially have.

For example, if a given sequence is $a=[2, 2, 3, 4, 3, 1]$. Initially, there could be $2$ sets:

-   the first set consisting of $4$ nesting dolls with sizes $[1, 2, 3, 4]$;
-   a second set consisting of $2$ nesting dolls with sizes $[2, 3]$.

According to a given sequence of sizes of nesting dolls $a_1, a_2, \dots, a_n$, determine the minimum number of nesting dolls that can make this sequence.

Each set is completely used, so all its nesting dolls are used. Each element of a given sequence must correspond to exactly one doll from some set.

---
## 题目大意

俄罗斯套娃是一种彩绘娃娃形式的木制玩具，里面可以放一个较小尺寸的类似娃娃。

一套套娃包含一个或多个套娃，它们的大小为连续的正整数。因此，一组嵌套娃娃由两个数字描述： $s$ — 一组中最小嵌套娃娃的尺寸； $m$ — 一组中娃娃的数量。换句话说，该集合包含某个整数 $s$ 和 $m$ ( $s,m > 0$ ) 的大小 $s, s + 1, ..., s + m - 1$ 。

您有一套或多套嵌套娃娃。最近，您发现有人将您的所有套装混合在一起，并记录了一系列娃娃尺寸 - 整数 $a_1, a_2,..., a_n$ 。

您不记得自己有多少组，因此您想找到最初可以拥有的**最小**组数。

例如，如果给定序列是 $a=[2, 2, 3, 4, 3, 1]$ 。最初，可能有 $2$ 组：

- 第一组由 $4$ 个尺寸为 $[1, 2, 3, 4]$ 的嵌套娃娃组成；
- 第二组由 $2$ 嵌套娃娃组成，尺寸为 $[2, 3]$ 。

根据给定的嵌套娃娃尺寸序列 $a_1, a_2, ..., a_n$ ，确定可以组成该序列的最小嵌套娃娃数量。

每套都已完全使用，因此其所有嵌套娃娃均已使用。给定序列的每个元素必须恰好对应于某个集合中的一个玩偶。


## 输入

>


## 输出

>

---

## 我的思路
**哈希表/贪心**

> 题目意思就是找一个严格递增的子数组，最少可以分成几个。

> 我们用一个哈希表来统计每个数字出现的次数， $C++$ 哈希表会**自动排序**（按照数组大小从小到大排序），$Go$ 要转为一个数组来排序。我们用 `last` 来表示**上一个数**， `pre` 表示**上一个数的`个数`** 。

> 如果来到当前位置**不能和上个数连续**（ $last + 1 != x$ ）那么 $pre$ 就是 $0$ 。统计答案 `ans = max(0, c - pre)` 当前数字`个数`减去 `pre` 。如果当前数个数**比前一个小**，那么 $c - pre < 0$ 就是说我当前的数一定会`包含在`**前一个数组成的序列中**，那么**答案就不需要加**；如果 $c - pre > 0$ 说明**当前数会`溢出`**必须得**形成一个新的子序列**，新的子序列长度就是 `c - pre` （因为是**严格递增子序列**，所以一定必须新增 `c-pre` ）。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"sort"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		var v int
		cnt := map[int]int{}
		for range n {
			Fscan(in, &v)
			cnt[v]++
		}
		keys := make([]int, 0, len(cnt))
		for k := range cnt {
			keys = append(keys, k)
		}
		last := -1
		ans := 0
		pre := 0
		sort.Ints(keys)
		for _, x := range keys {
			if last+1 != x {
				pre = 0
			}
			ans += max(0, cnt[x]-pre)
			last, pre = x, cnt[x]
		}
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve() {
    int n;
    cin >> n;
    int v;
    map<int, int> cnt;
    for (int i = 0; i < n; i++) {
        cin >> v;
        cnt[v]++;
    }
    int last = -1;
    int ans = 0;
    int pre = 0;
    for (auto [x, c] : cnt) {
        if (last + 1 != x) {
            pre = 0;
        }
        ans += max(0, c-pre);
        last = x, pre = c;
    }
    cout << ans << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) solve();

    return 0;
}
```
---
## Python 代码

```Python
```
