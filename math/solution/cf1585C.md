# [cf1585C] [Minimize Distance](https://codeforces.com/problemset/problem/1585/C)
## 题目描述 

> A total of ndepots are located on a number line. Depot i lies at the point xifor 1≤i≤n.
You are a salesman with n bags of goods, attempting to deliver one bag to each of the n depots. You and the n bags are initially at the origin 0. You can carry up to k bags at a time. You must collect the required number of goods from theorigin, deliver them to the respective depots, and then return to the origin to collect your next batch of goods.Calculate the minimum distance you need to cover to deliver all the bags of goods to the depots. You do not have to return to the origin after you have delivered all the bags. 

> 数线上共有 n个车厂。车厂i位于 1≤i≤n的点 xi上。你是一名售货员，带着 n 袋货物，试图向 n个仓库各运送一袋。您和 n袋货物最初到达 0起点。您每次最多可以运送 k袋。你必须从原产地领取所需数量的货物，将它们运送到相应的仓库，然后返回原产地领取下一批货物。计算将所有货物运送到仓库所需的最短距离。送完所有袋子的货物后，您无需返回原产地。

> 每个测试用例的第一行包含两个整数 n和 k ( 1≤k≤n≤2⋅10的5次方 )。( 1≤k≤n≤2⋅10的5次方).每个测试用例的第二行包含 n个整数 x1,x2,…,x ( −10的9次方≤xi≤10的9次方 )。某些车厂可能共享相同的位置。保证所有测试用例中 n的总和不超过 2⋅10的5次方。
---

## 我的思路
**贪心**

##


题目意思就是说我可以一趟拿k个货物，然后把货物分发给n个地方，每个地方位置为a[i]，每一趟分发完后需要回到原点0重新取货，并且最后一趟不需要再回到原点。求发完所有的货需要走的最短距离

- 1.由于最后一趟不需要回到原点，那么我最后一趟跑最远的肯定是最优的（因为不需要再跑回原点）。
- 2.跑一次我们肯定是发完能发的k个货物最优，跑一次的话，几个地方相距最近的也是最优。
- 3.那么我们可以先对数组a进行排序，由于a[i]大小有正数和负数，我们可以分两个大流程，一个发正数，一个发负数。那么我们需要找到第一个a[i] > 0的pos位置。
- 4.我们就分别从i = n-1和 i = 0 开始，由于我们已经拍好了顺序，我们每一趟的答案ans只需要加最远的，由于有往返路程，所以ans需要乘以2
- 5.最后我们比较最远的一趟(-a[0],a[n-1])，由于我们已经排好序了，不管a[0]a[n-1]是否为正数或者负数都是可以比较出来的，避免麻烦取绝对值也好

##
---

## 时间复杂度

O(n)

---

## 空间复杂度

O(n)

---

## Go 代码

```Go

package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
	"sort"
)

func solve(in io.Reader, out io.Writer) {
	var t, n, k int
	for Fscan(in, &t); t > 0; t-- {
		Fscan(in, &n, &k)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		slices.Sort(a)
		ans := 0
		pos := sort.SearchInts(a, 0)
		for i := n - 1; i >= pos; i -= k {
			ans += a[i]
		}
		for i := 0; i < pos; i += k {
			ans -= a[i]
		}
		Fprintln(out, ans*2-max(-a[0], a[n-1]))
	}
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}


```
---

## C++ 代码

```C++

#include <bits/stdc++.h>
using namespace std;


void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (auto &x : a) cin >> x;
    sort(a.begin(),a.end());
    int pos = lower_bound(a.begin(), a.end(), 0) - a.begin();
    long long ans = 0;
    for (int i = n - 1;i >= pos; i -= k) {
        ans += a[i];
    }
    for (int i = 0; i < pos; i += k) {
        ans -= a[i];
    }
    cout <<  ans * 2 - max(a[n-1],-a[0]) << "\n";
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while (t--) solve();
    return 0;
}


```
---
## Python 代码

```Python



```
