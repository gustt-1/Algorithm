# [cf1893B] [Neutral Tonality](https://codeforces.com/problemset/problem/1893/B)
## 题目描述 

> You are given an array $a$ consisting of $n$ integers, as well as an array $b$ consisting of $m$ integers.
Let $\text{LIS}(c)$ denote the length of the [longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of array $c$. For example, $\text{LIS}([2, \underline{1}, 1, \underline{3}])$ = $2$, $\text{LIS}([\underline{1}, \underline{7}, \underline{9}])$ = $3$, $\text{LIS}([3, \underline{1}, \underline{2}, \underline{4}])$ = $3$.
You need to insert the numbers $b_1, b_2, \ldots, b_m$ into the array $a$, at any positions, in any order. Let the resulting array be $c_1, c_2, \ldots, c_{n+m}$. You need to choose the positions for insertion in order to **minimize** $\text{LIS}(c)$.
Formally, you need to find an array $c_1, c_2, \ldots, c_{n+m}$ that simultaneously satisfies the following conditions:
-   The array $a_1, a_2, \ldots, a_n$ is a subsequence of the array $c_1, c_2, \ldots, c_{n+m}$.
-   The array $c_1, c_2, \ldots, c_{n+m}$ consists of the numbers $a_1, a_2, \ldots, a_n, b_1, b_2, \ldots, b_m$, possibly rearranged.
-   The value of $\text{LIS}(c)$ is the **minimum** possible among all suitable arrays $c$.

---
## 题目大意

> 给你一个由 $n$ 个整数组成的数组 $a$ 和由 $m$ 个整数组成的数组 $b$。  
让 $\text{LIS}(c)$ 表示数组 $c$ 的 [最长递增子序列](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) 的长度。例如：
- $\text{LIS}([2, \underline{1}, 1, \underline{3}]) = 2$  
- $\text{LIS}([\underline{1}, \underline{7}, \underline{9}]) = 3$  
- $\text{LIS}([3, \underline{1}, \underline{2}, \underline{4}]) = 3$  
你需要在数组 $a$ 的任意位置以任意顺序插入数字 $b_1, b_2, \dots, b_m$。得到的数组为 $c_1, c_2, \dots, c_{n+m}$。  
你需要选择插入的位置以 **最小化** $\text{LIS}(c)$。




## 输入

> **Input**
Each test contains multiple test cases. The first line contains a single integer $t$ $(1 \leq t \leq 10^4)$ — the number of test cases. The description of the test cases follows.
The first line of each test case contains two integers $n, m$ $(1 \leq n \leq 2 \cdot 10^5, 1 \leq m \leq 2 \cdot 10^5)$ — the length of array $a$ and the length of array $b$.
The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ $(1 \leq a_i \leq 10^9)$ — the elements of the array $a$.
The third line of each test case contains $m$ integers $b_1, b_2, \ldots, b_m$ $(1 \leq b_i \leq 10^9)$ — the elements of the array $b$.
It is guaranteed that the sum of $n$ over all test cases does not exceed $2\cdot 10^5$, and the sum of $m$ over all test cases does not exceed $2\cdot 10^5$.



## 输出

> **Output**
For each test case, output $n + m$ numbers — the elements of the final array $c_1, c_2, \ldots, c_{n+m}$, obtained after the insertion, such that the value of $\text{LIS}(c)$ is minimized. If there are several answers, you can output any of them.

---

## 我的思路
**贪心**

##

> 我们只需要最小化插入后的LIS。如果我们一开始就在a数组开头插入一个比a[i]小的b[j]那么一定会在原数组a的LIS增加1。那么我们一定可以确定的是把所有的比a[0]大的所有b[j]加入到a[0]前面，这一定是最优的，至少不会在原来的a的LIS增加。那么后续呢？假设一个0~n-1之间有一个k小于i的a[i]和a[k]，和一个比a[i]小的并且比a[k]大的b[j]。我们无论将b[j]放在a[i]前面那么我们的LIS又会增加一，如果同时还在a[k]后面那么同时又增加1，那么这样就增加2的，肯定不好。因为我们怎么都会增加1，更优的就是把b[j]放在a[k]前，这样我们就最大程度地减少LIS的增加。

> 我们就首先将b从大到小排序，外层遍历a,内层遍历b，只要b比a大就插入，最后如果还剩余b，我们就全部放到a结尾就行。


##
---

## 时间复杂度

O()

---

## 空间复杂度

O()

---

## Go 代码

```Go


package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
)

type (
	i64 = int64
	i32 = int32
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, m int
		Fscan(in, &n, &m)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		b := make([]int, m)
		for i := range b {
			Fscan(in, &b[i])
		}
		slices.SortFunc(b, func(a, b int) int { return b - a })
		j := 0
		for _, aa := range a {
			for ; j < m && b[j] > aa; j++ {
				Fprint(out, b[j], " ")
			}
			Fprint(out, aa, " ")
		}
		for _, v := range b[j:] {
			Fprint(out, v, " ")
		}
		Fprintln(out)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}




```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python



```
