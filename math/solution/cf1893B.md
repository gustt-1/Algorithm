# [cf1893B] [Neutral Tonality](https://codeforces.com/problemset/problem/1893/B)
## 题目描述 

> You are given an array $a$ consisting of $n$ integers, as well as an array $b$ consisting of $m$ integers.
Let $\text{LIS}(c)$ denote the length of the [longest increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of array $c$. For example, $\text{LIS}([2, \underline{1}, 1, \underline{3}])$ = $2$, $\text{LIS}([\underline{1}, \underline{7}, \underline{9}])$ = $3$, $\text{LIS}([3, \underline{1}, \underline{2}, \underline{4}])$ = $3$.
You need to insert the numbers $b_1, b_2, \ldots, b_m$ into the array $a$, at any positions, in any order. Let the resulting array be $c_1, c_2, \ldots, c_{n+m}$. You need to choose the positions for insertion in order to **minimize** $\text{LIS}(c)$.
Formally, you need to find an array $c_1, c_2, \ldots, c_{n+m}$ that simultaneously satisfies the following conditions:
-   The array $a_1, a_2, \ldots, a_n$ is a subsequence of the array $c_1, c_2, \ldots, c_{n+m}$.
-   The array $c_1, c_2, \ldots, c_{n+m}$ consists of the numbers $a_1, a_2, \ldots, a_n, b_1, b_2, \ldots, b_m$, possibly rearranged.
-   The value of $\text{LIS}(c)$ is the **minimum** possible among all suitable arrays $c$.

---
## 题目大意

> 给你一个由 $n$ 个整数组成的数组 $a$ 和由 $m$ 个整数组成的数组 $b$。  
让 $\text{LIS}(c)$ 表示数组 $c$ 的 [最长递增子序列](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) 的长度。例如：
- $\text{LIS}([2, \underline{1}, 1, \underline{3}]) = 2$  
- $\text{LIS}([\underline{1}, \underline{7}, \underline{9}]) = 3$  
- $\text{LIS}([3, \underline{1}, \underline{2}, \underline{4}]) = 3$  
你需要在数组 $a$ 的任意位置以任意顺序插入数字 $b_1, b_2, \dots, b_m$。得到的数组为 $c_1, c_2, \dots, c_{n+m}$。  
你需要选择插入的位置以 **最小化** $\text{LIS}(c)$。




## 输入

> **Input**
Each test contains multiple test cases. The first line contains a single integer $t$ $(1 \leq t \leq 10^4)$ — the number of test cases. The description of the test cases follows.
The first line of each test case contains two integers $n, m$ $(1 \leq n \leq 2 \cdot 10^5, 1 \leq m \leq 2 \cdot 10^5)$ — the length of array $a$ and the length of array $b$.
The second line of each test case contains $n$ integers $a_1, a_2, \ldots, a_n$ $(1 \leq a_i \leq 10^9)$ — the elements of the array $a$.
The third line of each test case contains $m$ integers $b_1, b_2, \ldots, b_m$ $(1 \leq b_i \leq 10^9)$ — the elements of the array $b$.
It is guaranteed that the sum of $n$ over all test cases does not exceed $2\cdot 10^5$, and the sum of $m$ over all test cases does not exceed $2\cdot 10^5$.



## 输出

> **Output**
For each test case, output $n + m$ numbers — the elements of the final array $c_1, c_2, \ldots, c_{n+m}$, obtained after the insertion, such that the value of $\text{LIS}(c)$ is minimized. If there are several answers, you can output any of them.

---

## 我的思路
**贪心**

##

> 我们只需要`最小化`插入后的 $LIS$ 。如果我们一开始就在 $a$ 数组开头插入一个比 $a_i$ 小的 $b_j$ 那么一定会在原数组 $a$ 的 $LIS$ 增加 $1$ 。那么我们一定可以确定的是把所有的比 $a_0$ 大的所有 $b_j$ 加入到 $a_0$ 前面，这一定是最优的，至少不会在原来的a的LIS增加。那么后续呢？假设一个 $0~n-1$ 之间有一个 $k$ **小于** $i$ 的 $a_i$ 和 $a_k$ ，和一个比 $a_i$ 小的并且比 $a_k$ 大的 $b_j$ 。我们无论将 $b_j$ 放在  $a_i$ 前面那么我们的 $LIS$ 又会增加一，如果同时还在 $a_k$ 后面那么同时又增加 $1$ ，那么这样就增加 $2$ 的，肯定不好。因为我们怎么都会增加 $1$ ，更优的就是把 $b_j$ 放在 $a_k$ 前，这样我们就最大程度地减少 $LIS$ 的增加。

> 我们就首先将 $b$ `从大到小`排序，外层遍历 $a$ ,内层遍历 $b$ ，只要 $b$ 比 $a$ 大就插入，最后如果还剩余 $b$ ，我们就全部放到 $a$ 结尾就行。


##
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"slices"
)

type (
	i64 = int64
	i32 = int32
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, m int
		Fscan(in, &n, &m)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		b := make([]int, m)
		for i := range b {
			Fscan(in, &b[i])
		}
		slices.SortFunc(b, func(a, b int) int { return b - a })
		j := 0
		for _, aa := range a {
			for ; j < m && b[j] > aa; j++ {
				Fprint(out, b[j], " ")
			}
			Fprint(out, aa, " ")
		}
		for _, v := range b[j:] {
			Fprint(out, v, " ")
		}
		Fprintln(out)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}
```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
