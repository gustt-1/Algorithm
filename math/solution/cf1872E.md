# [cf1872E] [Data Structures Fan](https://codeforces.com/problemset/problem/1872/E)

## 题目描述
You are given an array of integers $a_1, a_2, \ldots, a_n$, as well as a binary string$^{\dagger}$ $s$ consisting of $n$ characters.

Augustin is a big fan of data structures. Therefore, he asked you to implement a data structure that can answer $q$ queries. There are two types of queries:

-   "1 $l$ $r$" ($1\le l \le r \le n$) — replace each character $s_i$ for $l \le i \le r$ with its opposite. That is, replace all $\texttt{0}$ with $\texttt{1}$ and all $\texttt{1}$ with $\texttt{0}$.
-   "2 $g$" ($g \in \{0, 1\}$) — calculate the value of the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of the numbers $a_i$ for all indices $i$ such that $s_i = g$. Note that the $\operatorname{XOR}$ of an empty set of numbers is considered to be equal to $0$.

Please help Augustin to answer all the queries!

For example, if $n = 4$, $a = [1, 2, 3, 6]$, $s = \texttt{1001}$, consider the following series of queries:

1.  "2 $0$" — we are interested in the indices $i$ for which $s_i = \tt{0}$, since $s = \tt{1001}$, these are the indices $2$ and $3$, so the answer to the query will be $a_2 \oplus a_3 = 2 \oplus 3 = 1$.
2.  "1 $1$ $3$" — we need to replace the characters $s_1, s_2, s_3$ with their opposites, so before the query $s = \tt{1001}$, and after the query: $s = \tt{0111}$.
3.  "2 $1$" — we are interested in the indices $i$ for which $s_i = \tt{1}$, since $s = \tt{0111}$, these are the indices $2$, $3$, and $4$, so the answer to the query will be $a_2 \oplus a_3 \oplus a_4 = 2 \oplus 3 \oplus 6 = 7$.
4.  "1 $2$ $4$" — $s = \tt{0111}$ $\to$ $s = \tt{0000}$.
5.  "2 $1$" — $s = \tt{0000}$, there are no indices with $s_i = \tt{1}$, so since the $\operatorname{XOR}$ of an empty set of numbers is considered to be equal to $0$, the answer to this query is $0$.

$^{\dagger}$ A binary string is a string containing only characters $\texttt{0}$ or $\texttt{1}$.



---

## 题目大意
给你一个长度为 n 的数组 $a$ ，以及一个长度为 $n$ 的二进制字符串 $s$ 。

有 $q$ 次查询 ，每次查询有两种操作为 $tm$:

- `tm = 1`. 给你一个区间 [$l$, $r$] ($1\le l \le r \le n$) — 反转 $s$ 中从 $l$ 到 $r$ 的子数组。
- `tm = 2`. 给你一个 $g$ , ($g \in \{0, 1\}$) — 计算 $a$ 中所有 $s_i = g$ 的 $i$ 对应的 $a_i$ 的异或和。如果没有这样的 $i$，则答案为 $0$。


---

## 输入




## 输出

> 

---

## 我的思路

**思维/异或性质**

> 通过试着模拟模拟一下可以发现，如果要反转一个区间的所有数，我们可以不用关心反转后的数组长什么样子，**只需要关心反转后的数的异或和**就可以了。假设**长度为** $1$ 的子数组反转，那么**反转后的的异或和**就是`异或它本身`（异或的性质）。如果是更长的长度呢，也可以发现是异或这个子数组**所有数的异或和**。所有我们可以用一个 $pres$ 记录上次整个数组的 $s_i == 1$ 的异或和，然后用 $prexor$ 记录整个数组的**前缀异或和**（`不管 s_i 是 0 还是 1`），那么反转后的整个数组 $s_i$ 为 $1$ 的异或和即为 $pers \oplus = prexor[r] \oplus prexor[l]$ （修改 $pres$） 。如果查询 $g = 0$ ，其实也就是反转整个区间了，即 $curs = pres \oplus prexor[n] \oplus prexor[0]$ 防止修改 $pres$ 。



---

## 时间复杂度

$O()$ 

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type Number interface {
	~int | ~int8 | ~int32 | ~int64 |
		~uint | ~uint32 | ~uint64 |
		~float32 | ~float64
}

type Signed interface {
	~int | ~int8 | ~int32 | ~int64
}

type (
	i8  = int8
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func abs[T Signed](x T) T {
	if x < 0 {
		return -x
	}
	return x
}

func gcd[T Signed](a, b T) T {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}

func lcm[T Signed](a, b T) T {
	if a == 0 || b == 0 {
		return 0
	}
	return a / gcd(a, b) * b
}

func max[T Number](x, y T) T {
	if x > y {
		return x
	}
	return y
}

func min[T Number](x, y T) T {
	if x < y {
		return x
	}
	return y
}

func getPre(arr []int) []int {
	n := len(arr)
	res := make([]int, n+1)
	for i := range n {
		res[i+1] = res[i] + arr[i]
	}
	// l ~ r ：pre[r+1] - pre[l]
	return res
}

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		var s string
		Fscan(in, &n)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		Fscan(in, &s)

		pre_s := 0
		prexor := make([]int, n+1)
		for i := range n {
			if s[i] == '1' {
				pre_s ^= a[i]
			}
			prexor[i+1] = prexor[i] ^ a[i]
		}

		var q int
		Fscan(in, &q)
		var tm int
		for range q {
			Fscan(in, &tm)
			if tm == 1 { // 反转一次就是异或 [l, r] 子数组
				var l, r int
				Fscan(in, &l, &r)
				l--
				pre_s ^= prexor[r] ^ prexor[l]
			} else {
				var g int
				Fscan(in, &g)
				cur_s := pre_s
				if g == 0 {
					cur_s ^= prexor[n] ^ prexor[0]
				}
				Fprint(out, cur_s, " ")
			}
		}
		Fprintln(out)
	}
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```