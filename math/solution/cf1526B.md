# [cf1526B] [I Hate 1111](https://codeforces.com/problemset/problem/1526/B)

## 题目描述
> You are given an integer $x$. Can you make $x$ by summing up some number of $11, 111, 1111, 11111, \ldots$? (You can use any number among them any number of times).
For instance,
-   $33=11+11+11$
-   $144=111+11+11+11$


---
## 题目大意

> 给你一个整数 $x$ 。您能通过将一些 $11, 111, 1111, 11111, \ldots$ 相加得到 $x$ 吗？ （您可以多次使用其中的任何数字）。
例如，

- $33=11+11+11$
- $144=111+11+11+11$



## 输入

>


## 输出

>

---

## 我的思路
**数学/思维**


> 注意到， $1111 = 11 * 100 + 11$ ，类似的， $11111 = 111 * 100 + 11$ 。那么注意到我们就可以仅仅使用 $11$ 和 $111$ 来构造处更大的 $X$ ，所以我们只需要检查是否可以使用 $11$ 和 $111$ 来构造 $X$ 就可以了。

> 我们可以用一个 $X = A * 11 + B * 111$ ， 并且可以得出 $B = C * 11 + D （ { D | [0, 10] } ）$ 。可以整理得到 $X = (A + 111 * C) + 111 * D$ 。我们有约束的只有 D ，那么也就是 $X = k * 11 + D * 111$ 。即我们只需要判断 $(X - D * 111) % 11 == 0$ 即可。也就是枚举每个 $D (0 <= D < 11) and (111 * D <= X)$ 。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var x int
		Fscan(in, &x)
		ans := false
		for i := 0; i < 11; i++ {
			if 111*i <= x && (x-i*111)%11 == 0 {
				ans = true
			}
		}
		if ans {
			Fprintln(out, "YES")
		} else {
			Fprintln(out, "NO")
		}
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
