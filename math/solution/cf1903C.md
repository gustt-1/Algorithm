# [cf1903C] [Theofanis' Nightmare](https://codeforces.com/problemset/problem/1903/C)

## 题目描述
Theofanis easily gets obsessed with problems before going to sleep and often has nightmares about them. To deal with his obsession he visited his doctor, Dr. Emix.

In his latest nightmare, he has an array $a$ of size $n$ and wants to divide it into non-empty subarrays$^{\dagger}$ such that every element is in exactly one of the subarrays.

For example, the array $[1,-3,7,-6,2,5]$ can be divided to $[1] [-3,7] [-6,2] [5]$.

The Cypriot value of such division is equal to $\Sigma_{i=1}^{k} i \cdot \mathrm{sum}_i$ where $k$ is the number of subarrays that we divided the array into and $\mathrm{sum}_i$ is the sum of the $i$\-th subarray.

The Cypriot value of this division of the array $[1] [-3,7] [-6,2] [5] = 1 \cdot 1 + 2 \cdot (-3 + 7) + 3 \cdot (-6 + 2) + 4 \cdot 5 = 17$.

Theofanis is wondering what is the **maximum** Cypriot value of any division of the array.

$^{\dagger}$ An array $b$ is a subarray of an array $a$ if $b$ can be obtained from $a$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. In particular, an array is a subarray of itself.



---

## 题目大意
给你一个数组 $a$ ，你需要将它分成多个非空子数组。你需要最大化 $\Sigma_{i=1}^{k} i \cdot \mathrm{sum}_i$ ，即假设新划分出的数组为 $b$ ，你需要最大化 $sum(b[i] * (i+1))$




---

## 输入




## 输出

> 

---

## 我的思路

**边际收益贪心**

> 我们先预处理一个 $suf$ 数组，即当前位置 $i$ 到 $n$ 的后缀和。

> 从前往后贪心的考虑每个位置的 $suf$ ，如果 $suf[i] > 0$ 我们可以在此处直接切一刀划分，此时划分一定是盈利的选择，如果 $suf[i] <= 0$ 我们就不能在此处划分了，只能把它归到**上一个子数组**中，因为划分的越多那么 $i$ 就会变得的**越来越大**，如果在此处划分的化**亏损一定是更大化**的。

**如何统计答案呢？为什么不需要处理乘以 i ？**

> 我们划分一次就会加一次 $suf[i]$ ，所以后面的数如果我们在前面划分了 $n$ 次，那么 $suf[k]$ 中每个数都会为答案加上 $n$ 次。所以我们的乘以 $i$ 这个因子隐藏在了加 $suf[i]$ 这个操作中。所以不需要再去额外处理乘以 $i$ 了




---

## 时间复杂度

$O()$ 

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	type pair struct {
		v, c int
	}
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		a := make([]int, n)
		for i := range a {
			Fscan(in, &a[i])
		}
		suf := make([]int, n+1)
		suf[n] = 0
		for i := n - 1; i >= 0; i-- {
			suf[i] = suf[i+1] + a[i]
		}
		ans := suf[0]
		for i := range n {
			if suf[i+1] > 0 {
				ans += suf[i+1]
			}
		}
		Fprintln(out, ans)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(a, b int) int {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}

func max64(x, y int64) int64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y int64) int64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}
```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```

---

## JavaScript 代码

```JavaScript

```
