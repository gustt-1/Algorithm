# [cf2110C] [Racing](https://codeforces.com/problemset/problem/2110/C)

## 题目描述
In 2077, a sport called hobby-droning is gaining popularity among robots.

You already have a drone, and you want to win. For this, your drone needs to fly through a course with $n$ obstacles.

The $i$\-th obstacle is defined by two numbers $l_i, r_i$. Let the height of your drone at the $i$\-th obstacle be $h_i$. Then the drone passes through this obstacle if $l_i \le h_i \le r_i$. Initially, the drone is on the ground, meaning $h_0 = 0$.

The flight program for the drone is represented by an array $d_1, d_2, \ldots, d_n$, where $h_{i} - h_{i-1} = d_i$, and $0 \leq d_i \leq 1$. This means that your drone either does not change height between obstacles or rises by $1$. You already have a flight program, but some $d_i$ in it are unknown and marked as $-1$. Replace the unknown $d_i$ with numbers $0$ and $1$ to create a flight program that passes through the entire obstacle course, or report that it is impossible.


---
## 题目大意

$2077$ 年，一项名为业余爱好无人机的运动在机器人中越来越受欢迎。

您已经拥有一架无人机，并且您想获胜。为此，您的无人机需要飞过有 $n$ 障碍物的航线。

第 $i$ 个障碍物由两个数字 $l_i, r_i$ 定义。令无人机在第 $i$ 个障碍物处的高度为 $h_i$ 。如果 $l_i <= h_i <= r_i$ ，那么无人机就会穿过这个障碍物。最初，无人机在地面上，即 $h_0 = 0$ 。

无人机的飞行程序由数组 $d_1, d_2, ..., d_n$ 表示，其中 $h_i - h_{i-1} = d_i$ 和 $0 <= d_i <= 1$ 。这意味着您的无人机不会改变障碍物之间的高度，或者会上升 $1$ 。您已有一个航班计划，但其中的某些 $d_i$ 未知并标记为 $-1$ 。将未知的 $d_i$ 替换为数字 $0$ 和 $1$ ，以创建穿过整个障碍路线的飞行程序，或者报告这是不可能的。



## 输入

>


## 输出

>

---

## 我的思路
**反悔贪心**

> 我们用一个 $sig$ 数组来标记 $d_i = -1$ 的位置，后续我们就可以根据情况来修改标记过的位置。另外我们再用一个变量 $cursum$ 来表示来到 $i$ 位置累计的高度（不算上 $d[i] = -1$）

> 如果我们来到的 `i` 位置， `cursum < l[i]` ，并且我们来到 `i` 位置时标记的可以修改的位置为空说明我们**没办法提高高度**了，那么直接输出 `-1` 。否则我们随意拿来标记的最后一个来将其改成 `1` **提高高度**。如果 `cursum+len(sig) > r[i]` 表示我之前标记的所有位置都**假设改成** `1` 超出了 $r[i]$ ，如果可以修改的位置为空说明我们**没办法降低高度**，直接输出 `-1` 。否则我们将标记的位置改成 `0` 来**降低高度**，

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		d := make([]int, n)
		for i := range d {
			Fscan(in, &d[i])
		}
		l := make([]int, n)
		r := make([]int, n)
		for i := 0; i < n; i++ {
			Fscan(in, &l[i], &r[i])
		}
		cursum := 0
		sig := []int{}

		for i := 0; i < n; i++ {
			if d[i] == -1 {
				sig = append(sig, i)
			} else {
				cursum += d[i]
			}

			for cursum < l[i] {
				if len(sig) == 0 {
					Fprintln(out, -1)
					goto next
				}
				pos := sig[len(sig)-1]
				sig = sig[:len(sig)-1]
				d[pos] = 1
				cursum++
			}
			for cursum+len(sig) > r[i] {
				if len(sig) == 0 {
					Fprintln(out, -1)
					goto next
				}
				pos := sig[len(sig)-1]
				sig = sig[:len(sig)-1]
				d[pos] = 0
			}
		}

		for i := range d {
			if d[i] < 0 {
				d[i] = 0
			}
		}
		for _, x := range d {
			Fprint(out, x, " ")
		}
		Fprintln(out)
	next:
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
