# [cf1766D] [Lucky Chains](https://codeforces.com/problemset/problem/1766/D)
## 题目描述 

> Let's name a pair of positive integers $(x, y)$ lucky if the greatest common divisor of them is equal to $1$ ($\gcd(x, y) = 1$).
Let's define a chain induced by $(x, y)$ as a sequence of pairs $(x, y)$, $(x + 1, y + 1)$, $(x + 2, y + 2)$, $\dots$, $(x + k, y + k)$ for some integer $k \ge 0$. The length of the chain is the number of pairs it consists of, or $(k + 1)$.
Let's name such chain lucky if all pairs in the chain are lucky.
You are given $n$ pairs $(x_i, y_i)$. Calculate for each pair the length of the longest lucky chain induced by this pair. Note that if $(x_i, y_i)$ is not lucky itself, the chain will have the length $0$.

---
## 题目大意

> 




## 输入

> 

## 输出

> 

---

## 我的思路
**$gcd$**

##

> 对于不互质的两个数，设 x, y ，那么就要找 gcd(x+k, y+k) 即我们可以找 $(x + k) / (y + k) => (d + y + k) / (y + k) => d / (y + k) + 1 (d = x - y)$ 。那么可以得出找 $gcd(x+k, d)$ ， $x + k ≡ 0 (mod$  $p) => k ≡ (-x) mod$ $p => k ≡ (p - x$ $mod$ $p) mod$ $p$ 。即我们要找到 $d$ 的最小的一个质因子 $p$

> 由于 $gcd(x,y) = gcd(x,y-x)$ ，所以 $gcd(x+k,y+k) = gcd(x+k,y-x)$ 。如果 $y-x = 1$ ，那么 $gcd(x+k,y-x)$  恒为 $1$ ，输出 $-1$ 。否则，当且仅当 $x+k$ 是 $y-x$ 的某个质因子 $p$ 的**倍数**时，  $gcd(x+k,y-x) > 1$ 。我们需要算出 $x$ 到 $>= x$ 的 $p$ 的**倍数的最小距离**，即 $k = (p - p$ $mod$ $x)$ $mod$ $p$ ，更新答案的最小值。预处理 $LPF$（最小质因子），可以快速分解 $y-x$ 。


##
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
)

func solve(in io.Reader, out io.Writer) {
	var T int
	const mx u32 = 1e7
	lpf := [mx]u32{}
	for i := u32(2); i < mx; i++ {
		if lpf[i] == 0 {
			for j := i; j < mx; j += i {
				if lpf[j] == 0 {
					lpf[j] = i
				}
			}
		}
	}
	var x, y u32
	for Fscan(in, &T); T > 0; T-- {
		Fscan(in, &x, &y)
		y -= x
		if y == 1 {
			Fprintln(out, -1)
			continue
		}
		mn := y
		for y > 1 {
			p := lpf[y]
			for y /= p; y%p == 0; y /= p {
			}
			if x%p == 0 {
				mn = 0
				break
			}
			mn = min(mn, p-x%p)
		}
		Fprintln(out, mn)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}a

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```
