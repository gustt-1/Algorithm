# [cf2140C] [Ultimate Value](https://codeforces.com/problemset/problem/2140/C)
## 题目描述 

> Let's define a function $f(a)$ for an array $a$ of length $n$ as

 $$f(a) = cost + (a_1 - a_2 + a_3 - a_4 ... a_n)$$ where $\textrm{cost}$ is zero initially.

> Now consider the scenario where Alice and Bob are given an array $a$ of length $n$. They play a game taking at most $10^{100}$ turns alternately with Alice going first.
In each turn, they must perform any **one** (only one) of the following operations:
-   End the game for both Alice and Bob.
-   Choose two indices $l,r$ with $1 \le l \le r \le n$ and swap $a_l$ and $a_r$; this adds $(r - l)$ to the $\textrm{cost}$.
Assume that Alice tries to maximize $f(a)$ and Bob tries to minimize it.
Your task is to determine the final value of $f(a)$ assuming both players play optimally.

---
## 题目大意

> 



## 输入

> 


## 输出

> 

---

## 我的思路
**数学/思维**


> $Bob$ 操作后， $Alice$ 可以把 $Bob$ 交换的两个数再换回来，这只会让 $f(a)$ 变得更大。
所以 $Bob$ 的最优决策是立刻结束游戏。
所以只有一次交换。
考虑计算 $f(a)$ 交换后的增量的最大值。
如果交换的两个数前面的正负号相同，那么这两个数越远越好，最远距离为 $n-2+n%2$ 。
如果交换的两个数前面的正负号不同，我们可以枚举右维护左。
- 如果 $a[i]$ 前面是负号，那么和一个前面是正号的 $a[j]$ 交换， $f(a)$ 增加了 `i-j+2*a[i]-2*a[j]`  ，所以维护左边的 $j+2*a[j]$ 的最小值。
- 如果 $a[i]$ 前面是正号，那么和一个前面是负号的 $a[j]$ 交换， $f(a)$ 增加了 `i-j-2*a[i]+2*a[j]`  ，所以维护左边的 $j-2*a[j]$ 的最小值。


---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		sum, d := 0, n-2+n%2
		pos, neg := int(1e18), int(1e18)
		var x int
		for i := range n {
			Fscan(in, &x)
			if i%2 > 0 {
				sum -= x
				d = max(d, i+2*x-pos) // pos = j + 2 * a[j]
				neg = min(neg, i-2*x) //负数下标
			} else {
				sum += x
				d = max(d, i-2*x-neg)
				pos = min(pos, i+2*x) //正数下标
			}
		}
		Fprintln(out, sum+d)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```
