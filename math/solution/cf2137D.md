# [cf2137D] [Replace with Occurrences](https://codeforces.com/problemset/problem/2137/D)

## 题目描述
Given an array $a$, let $f(x)$ be the number of occurrences of $x$ in the array $a$. For example, when $a=[1,2,3,1,4]$, then $f(1)=2$ and $f(3)=1$.

You have an array $b$ of size $n$. Please determine if there is an array $a$ of size $n$ such that $f(a_i)=b_i$ for all $1 \leq i \leq n$. If there is one, construct it.




---

## 题目大意
给定一个数组 $a$ ，令 $f(x)$ 为 $x$ 在数组 $a$ 中出现的次数。例如，当 $a=[1,2,3,1,4]$ 时，则为 $f(1)=2$ 和 $f(3)=1$ 。

您有一个大小为 $n$ 的数组 $b$ 。请确定是否存在大小为 $n$ 的数组 $a$ ，使得所有 $1 
<= i <= n$ 都满足 $f(a_i)=b_i$ 。如果有的话，就建造它。


---

## 输入




## 输出

> 

---

## 我的思路

**构造**

> 我们用 $cnt$ 来统计当前数 $x$ 出现的次数，初始时 $cnt = 0$ 。 $cur$ 来表示**当前位置应该填的数字**，如果 $cur$ **不为空**即代表之前**已经填过**该频次的数字了，则**继续填**。如果 $cur[x] = 0$ 即代表之前**没有填过该频次**的数字，则将 $cur[x]$ 设置为 $start$ ，并且让 $start$ ++ 为下个做准备。如果 $cnt[x] == x$ 说明该频次的数字已经填完了 $cnt[x], cur[x]$ 都置为 $0$ 。

---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		b := make([]int, n)
		check := make([]int, n+1)
		for i := range b {
			Fscan(in, &b[i])
			check[b[i]]++
		}
		start := 1
		cnt := make([]int, n+1)
		cur := make([]int, n+1)
		ans := make([]int, n)
		for i, x := range check {
			if x == 0 {
				continue
			}
			if x%i != 0 || x < i {
				Fprint(out, -1)
				goto outer
			}
		}

		for i, x := range b {
			if cur[x] != 0 {
				ans[i] = cur[x]
			} else {
				cur[x] = start
				ans[i] = start
				start++
			}
			cnt[x]++
			if x-cnt[x] > n-i+1 {
				Fprint(out, -1)
				goto outer
			}
			if cnt[x] == x {
				cnt[x] = 0
				cur[x] = 0
			}
		}

		for _, x := range ans {
			Fprint(out, x, " ")
		}
	outer:
		Fprintln(out)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}
```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```
