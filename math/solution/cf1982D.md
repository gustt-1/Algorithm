# [cf1982D] [Beauty of the mountains](https://codeforces.com/problemset/problem/1982/D)
## 题目描述 

> Nikita loves mountains and has finally decided to visit the Berlyand mountain range! The range was so beautiful that Nikita decided to capture it on a map. The map is a table of $n$ rows and $m$ columns, with each cell containing a non-negative integer representing the height of the mountain.
He also noticed that mountains come in two types:
-   With snowy caps.
-   Without snowy caps.

> Nikita is a very pragmatic person. He wants the sum of the heights of the mountains with snowy caps to be equal to the sum of the heights of the mountains without them. He has arranged with the mayor of Berlyand, Polikarp Polikarpovich, to allow him to transform the landscape.
Nikita can perform transformations on submatrices of size $k \times k$ as follows: he can add an integer constant $c$ to the heights of the mountains within this area, but the type of the mountain remains unchanged. Nikita can choose the constant $c$ independently for each transformation. **Note that $c$ can be negative**.
Before making the transformations, Nikita asks you to find out if it is possible to achieve equality of the sums, or if it is impossible. It doesn't matter at what cost, even if the mountains turn into canyons and have negative heights.
If only one type of mountain is represented on the map, then the sum of the heights of the other type of mountain is considered to be zero.



---
## 题目大意

> 尼基塔喜欢山，终于决定去贝里安德山脉看看！这座山脉如此美丽，尼基塔决定用地图记录下来。地图是一个由 $n$ 行和 $m$ 列组成的表格，每个单元格都包含一个非负整数，代表山的高度。
他还注意到，山有两种类型：

- 有雪盖。
- 无雪帽。

> 尼基塔是一个非常务实的人。他希望有雪帽的山的高度总和等于没有雪帽的山的高度总和。他已经和贝里安德的市长波利卡普-波利卡波维奇达成了协议，允许他改造地貌。
尼基塔可以对大小为 $k \times k$ 的子矩阵进行如下变换：他可以在该区域内的山脉高度上添加一个整数常数 $c$ ，但山脉的类型保持不变。尼基塔可以为每次变换独立选择常数 $c$ 。**注意 c 可以是负数**。
进行变换之前，尼基塔会要求您找出是否有可能实现总和相等，或者是否不可能。代价是什么并不重要，即使山变成了峡谷，高度是负数也没关系。
如果地图上只有一种类型的山，那么另一种类型的山的高度之和将被视为零。




## 输入

> Each test consists of several test cases. The first line contains an integer $t$ ($1 \le t \le 10^{4}$) — the number of test cases. This is followed by a description of test cases.
The first line of each test case contains three integers $n, m, k$ ($1 \le n, m \le 500, 1 \le k \le min(n, m)$).
The next $n$ lines of each test case contain $m$ integers $a_{i j}$ ($0 \le a_{i j} \le 10^{9}$) — the initial heights of the mountains.
The next $n$ binary strings of length $m$ for each test case determine the type of mountain, '$0$' — with snowy caps, '$1$' — without them.
It is guaranteed that the sum of $n \cdot m$ for all test cases does not exceed $250\,000$.



## 输出

> For each test case, output "YES" without quotes if it is possible to equalize the sums of the mountain heights, otherwise output "NO" without quotes. You can output each letter in any case (for example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as a positive answer).

---

## 我的思路
**裴蜀定理/二位前缀和**

##

> 要使得两种不同的山累计高度相等即使得两种山的高度差 `D = 0` 。

> 我们对一个 $k*k$ 的矩阵进行操作，假设我们的要加的值为 $c$ ，那么假设我们`有雪`的山的`个数`是 $a$ ，`没雪`的是 $b$，那么对于整个差值的贡献即为 $val = c * (a-b)$ 。也就是说我们一个子矩阵的差值贡献跟我们`有雪和没雪山的个数`有关。假设我们每个矩阵的个数差为 $t_{i}$ ，每个矩阵相对应需要加的值为 $c_{i}$ ，那么我们有所有差值的线性组合 $t_1 * c1 + t_2 * c_2 + ... + t_i * c_i$ 必须是 **高度总差值** $D$ 的一个因子。裴蜀定理告诉我们，对于整数集合 { $d_1, d_2, d_3 ... d_n$ } 所能组合出的整数即为 $GCD$ { $d_1, d_2, d_3, ..., d_n$ } 。那么我们对这些高度差的 $gcd$ 必须得是 **高度总差值** $D$ 的一个因子， 即 $resgcd$ = $gcd$ { $d_1, d_2, ..., d_n$ }。 $resgcd$ % $D == 0$ 。

> 求每个 $k*k$ 矩阵的个数差值可以用二位前缀和快速计算。
##
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

type (
	i64 = int64
	i32 = int32
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, m, k int
		Fscan(in, &n, &m, &k)
		h := make([][]int, n)
		for i := range h {
			h[i] = make([]int, m)
		}
		for i := 0; i < n; i++ {
			for j := 0; j < m; j++ {
				Fscan(in, &h[i][j])
			}
		}
		d := 0
		sum := make([][]int, n+1)
		for i := range sum {
			sum[i] = make([]int, m+1)
		}
		var s string
		for i, row := range h {
			Fscan(in, &s)
			for j, val := range row {
				var c int
				if s[j] == '1' {
					c = 1
				} else {
					c = -1
				}
				d += val * c
				sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + c
			}
		}
		get := func(r1, c1, r2, c2 int) int {
			return sum[r2][c2] - sum[r2][c1] - sum[r1][c2] + sum[r1][c1]
		}
		resgcd := 0
		for i := k; i <= n; i++ {
			for j := k; j <= m; j++ {
				resgcd = gcd(resgcd, get(i-k, j-k, i, j))
			}
		}
		if d == 0 || resgcd != 0 && d%resgcd == 0 {
			Fprintln(out, "YES")
		} else {
			Fprintln(out, "NO")
		}
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(a, b int) int {
	for a != 0 {
		a, b = b%a, a
	}
	return b
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}


```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python



```
