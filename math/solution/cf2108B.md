# [cf2108B] [SUMdamental Decomposition](https://codeforces.com/contest/2108/problem/B)

## 题目描述
On a recent birthday, your best friend Maurice gave you a pair of numbers $n$ and $x$, and asked you to construct an array of **positive** numbers $a$ of length $n$ such that $a_1 \oplus a_2 \oplus \cdots \oplus a_n = x$ $^{\text{∗}}$.

This task seemed too simple to you, and therefore you decided to give Maurice a return gift by constructing an array among all such arrays that has the smallest sum of its elements. You immediately thought of a suitable array; however, since writing it down turned out to be too time-consuming, Maurice will have to settle for just the sum of its elements.



---

## 题目大意
给你一个 $n$ ，和一个 $x$ ，你需要构造一个长度为 $n$ 的**正整数**数组 $a$ 。你需要使得 $a_0 \oplus a_1 \oplus \cdots \oplus a_{n-1} = x$ ，并且 $a_0 + a_1 + \cdots + a_{n-1}$ 最小。请你返回可以构造的数组的最小和。如果不能构造出来，返回 $-1$ 。

---

## 输入




## 输出

> 

---

## 我的思路

**位运算/贪心**


- 首先要满足条件，使得所有元素异或起来等于 $x$ ：可以知道这些元素在 $x$ 二进制下为 $1$ 的位上，**必须**包含 $1$ ，不然没办法保证异或起来等于 $x$ 。

- 保证和最小：贪心地考虑，由于我们上一步已经得出了可以满足条件的结论，那么最好的情况下就是把 $x$ 进行**拆位**，每一个为 $1$ 的位上的元素都设为 $2^i$ ，那么和就是最小的。

**设 $x$ 二进制位上为 $1$ 的个数为 $cntone$**

- 那么数组 $a$ 中就有 $cntone$ 个元素为 $2^i$ 。其他元素保证异或和为 $0$ 。由于 $a \oplus a == 0$ ，又由于 $a_i$ 必须大于 $1$ 。所以最好就是其他**全部**设置为 $1$ 。
    - 接下来考虑 $n, cntone$ 的奇偶性，如果两者相同，那么减去 $cntone$ 即为偶数了，那么可以将剩余的全部设置为 $1$ ，那么答案即是 $n - cntone + x$
    - 如果不相同，那么我们可以三个数 $1, 2, 3$ 凑出 $1 \oplus 2 \oplus 3 \oplus == 0$ ，然后就是偶数了，那么剩下全是 $1$ 


**最终答案如下：**
- 如果 $n <= cntone$ ，那么可以直接通过 $n$ 个数**直接异或**起来得到 $x$ ，那么答案为 $x$ 。
- 如果 $n$ 和 $cntone$ **奇偶性相同**，可以通过上述方法构造出来，答案为 $n - cntone + x$
- 如果 $n$ 和 $cntone$ **奇偶性不同**
    - 如果 $x > 1$ 可以通过上述方法构造出来，答案为 $x+n-cntone+1$
    - 如果 $x == 1$ ，也是通过上述方法，答案为 $n + 1 + 2 + 3 - 3 = n + 3$ （其中 $1, 2, 3$ 是为了凑出异或 $0$ ，减去 $3$ 是因为 $1, 2, 3$ 这三个数异或起来为 $0$ ，所以我们需要用这 $3$ 个数代替原本的 $1$ ）
    - 如果 $x == 0$ ，如果 $n == 1$ 那么这是**唯一**一个**不可以**构造出来的情况，返回 $-1$ 。否则，答案为 $n + 3$ 。


---

## 时间复杂度

$O(n)$ 

---

## 空间复杂度

$O(1)$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"math/bits"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func cnt_bits(x int) (cnt int) {
	for x > 0 {
		if x&1 == 1 {
			cnt++
		}
		x >>= 1
	}
	return
}

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, x int
		Fscan(in, &n, &x)
		cnt := bits.OnesCount(uint(x))

		if n <= cnt {
			Fprintln(out, x)
			continue
		} else if (n-cnt)&1 == 0 {
			Fprintln(out, x+n-cnt)
			continue
		} else {
			if x > 1 {
				Fprintln(out, x+n-cnt+1)
				continue
			}
			if x == 1 {
				Fprintln(out, n+3)
				continue
			} else {
				if n == 1 {
					Fprintln(out, "-1")
				} else {
					Fprintln(out, n+3)
				}
				continue
			}
		}
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++

```
---
## Python 代码

```Python

```

---

## JavaScript 代码

```JavaScript
```
