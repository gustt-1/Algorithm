# [cf1862D] [Ice Cream Balls](https://codeforces.com/problemset/problem/1862/D)
## 题目描述 

> Tema decided to improve his ice cream making skills. He has already learned how to make ice cream in a cone **using exactly two** balls.

Before his ice cream obsession, Tema was interested in mathematics. Therefore, he is curious about the **minimum** number of balls he needs to have in order to make **exactly** $n$ **different** types of ice cream.

There are plenty possible ice cream flavours: $1, 2, 3, \dots$. Tema can make two-balls ice cream with any flavours (probably the same).

Two ice creams are considered different if their sets of ball flavours are different. For example, $\{1, 2\} = \{2, 1\}$, but $\{1, 1\} \neq \{1, 2\}$.

For example, having the following ice cream balls: $\{1, 1, 2\}$, Tema can make only two types of ice cream: $\{1, 1\}$ and $\{1, 2\}$.

**Note, that Tema do not need to make all the ice cream cones at the same time. This means that he making ice cream cones independently. Also in order to make a following cone $\{x, x\}$ for some $x$, Tema needs at least $2$ balls of type $x$**.

Help Tema answer this question. It can be shown that answer always exist.

---
## 题目大意

> 有个人要做冰淇淋，一个冰淇淋需要用两个冰淇淋球做成。每种冰淇淋可以使用两个同一种的冰淇淋球做成，也可以用两种不同的冰淇淋球。然后给你一个 `n`，表示要做`恰好n种`冰淇淋球，求最少需要多少个冰淇淋球。 

**注：`{1, 2}` 和 `{2, 1}` 是`同一种`， `{1, 3}` 和 `{1, 1}`是`不同的`**




## 输入

> 



## 输出

> 
---

## 我的思路
**数学**

##

> 我们假设使用`两个冰淇淋球同一种`冰淇淋做的有 $x$ `种`，使用`不同的`有 $y$ `种`。那么使用`同一种`做的至少需要 $2 * x$ 个，`多了的话因为会重复`，贪心地想肯定是 `2 个是最好的`（因为`求的是最少`），那么使用`不同的` $y$ `种`可以和 $x$ `种`一起排列组合。

例如：`[1,1,2,2,3,3,4,5,6,7]` ，那么 $x$ 即为 `{1,1}, {2,2}, {3,3}` ， $y$ 为 `4,5,6,7` $y$ 可以加上 $x$ 一起`排列组合`，根据`组合的公式`那么就是 $$(x+y)*(x+y-1) / 2$$ 。我们假设 `k = x + y`

**根据一共有n种，我们可以得出 `x + k*(k-1)/2 == n`**

**可以知道我们需要的`个数`（答案）即为 `2*x+y`**


> 我们要**最小化答案**，那么就是 **最小化** $2*x+y$ ，因为 $x+y=k$ ， 得出 $y = k - x$ 那么就是 **最小化**  $x+k$ ，又根据  $x + k*(k-1)/2 == n$   ，我们又可以得出我们需要最小化答案 $k+n-k*(k-1)/2$ 根据 $x = n - k*(k-1)/2$ ，因为 $x$ `不可能小于零` ，那么我们又可以得出 $n - k*(k-1)/x >= 0$ ，即 $k * k - k - 2 * n <= 0$ ，这样我们可以得出满足的 `k 的最大值（k > 0是，函数是单调递增的）`，所以这样我们就求出了 $k$ 和 $k*(k-1)$ 的 `最大值` 。我们再看要 `最小化的答案` 为 $k+n-k*(k-1)/2$ ，那就是 `最大化`  $k$ 和 $k*(k-1)/2$ 那么我们就得出了`答案的最小值`。

##
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"math"
	"os"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		k := int((1 + math.Sqrt(f64(1+8*n))) / 2)
		if (k*k-k)/2 > n {
			k--
		}
		Fprintln(out, n+k-(k*k-k)/2)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```
