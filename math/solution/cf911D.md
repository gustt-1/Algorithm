# [cf2129B] [Stay or Mirror](https://codeforces.com/problemset/problem/2129/B)
## 题目描述 

> 大小为 n 的排列是一个大小为 n 的数组，从 1 到 n 的每个整数在这个数组中恰好出现一次。排列 p 中的反转是一对索引 (i, j) ，即 i > j 和 ai < aj 。例如，一个排列 [4, 1, 3, 2] 包含 4 个倒数： (2, 1) , (3, 1) , (4, 1) , (4, 3) .给你一个大小为 n 的排列 a 和 m 个查询。每个查询由两个索引 l 和 r 表示，您必须反转该排列的 [l, r] 段。例如，如果使用 a = [1, 2, 3, 4] 和查询 l = 2 , r = 4 ，那么得到的排列结果为 [1, 4, 3, 2] 。每次查询后，您都必须确定反转数是奇数还是偶数。

---


## 输入

> 第一行包含一个整数 n ( 1 ≤ n ≤ 1500 ) - 排列的大小。
第二行包含 n 个整数 a1 、 a2 、......、 an ( 1 ≤ ai ≤ n )--排列的元素。这些整数是成对不同的。
第三行包含一个整数 m ( 1 ≤ m ≤ 2·10^5 ) - 要处理的查询次数。
接下来是 m 行， i -行包含两个整数 li 、 ri 。( 1 ≤ li ≤ ri ≤ n )，表示 i 次查询是要逆转排列的 [li, ri] 段。所有查询都是相继进行的。



---

## 我的思路
**数学/集合**

##

> - 查询逆序对的奇偶性，我们从集合地角度思考，假设当前选中的子数组左右端点为l, r。那么长度集为len = (r-l+1)。那么可以组成的序对个数为len*(len-1)/2。如果逆序对的个数为x, 那么顺序对即是逆序对的补集，设顺序对个数为y，那么x+y = len*(len-1)/2，反转后逆序对就变成了顺序对，顺序对就变为了逆序对，那么逆序对的增量为len*(len-1)/2-2*x(x为原来逆序对的个数)。因为2*x为永远为偶数，那么我们只需要判断len*(len-1)/2的奇偶性即可，我们第一次反转子数组新的逆序对个数即为len*(len-1)/2-2*x + base（最初始的）。后续只需要判断奇偶性就可。如果len*（len-1）/2 为偶数，那么总数奇偶性不变（上一次操作是啥就是啥），若为奇数就反转奇偶性就可


##
---

## 时间复杂度

O()

---

## 空间复杂度

O()

---

## Go 代码

```Go


package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

type (
	i64 int64
	i32 int32
)

func solve(in io.Reader, out io.Writer) {
	//var T int
	//for Fscan(in, &T); T > 0; T-- {
	var n int
	Fscan(in, &n)
	a := make([]int, n)
	for i := 0; i < n; i++ {
		Fscan(in, &a[i])
	}
	var m int
	Fscan(in, &m)
	base := 0
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			if a[j] < a[i] {
				base++
			}
		}
	}
	var l, r int
	odd := false
	even := false
	if base%2 == 0 {
		even = true
	} else {
		odd = true
	}
	for k := 0; k < m; k++ {
		Fscan(in, &l, &r)
		ll := r - l + 1
		if (ll*(ll-1)/2)%2 == 1 {
			odd, even = even, odd
		}
		if even {
			Fprintln(out, "even")
		} else {
			Fprintln(out, "odd")
		}
	}
	//}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}



```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python



```
