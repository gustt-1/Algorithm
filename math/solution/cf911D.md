# [cf2129B] [Stay or Mirror](https://codeforces.com/problemset/problem/2129/B)
## 题目描述 

> 大小为 n 的排列是一个大小为 $n$ 的数组，从 $1$ 到 $n$ 的每个整数在这个数组中恰好出现一次。排列 p 中的反转是一对索引 $(i, j)$ ，即 $i>j$ 和 $a_i<a_j$ 。例如，一个排列 `[4, 1, 3, 2]`包含 $4$ 个倒数： `(2, 1) , (3, 1) , (4, 1) , (4, 3)` .给你一个大小为 $n$ 的排列 $a$ 和 $m$ 个查询。每个查询由两个索引 $l$ 和 $r$ 表示，您必须反转该排列的 `[l, r]` 段。例如，如果使用 `a = [1, 2, 3, 4]` 和查询 `l = 2 , r = 4` ，那么得到的排列结果为 `[1, 4, 3, 2]` 。每次查询后，您都必须确定反转数是奇数还是偶数。

---


## 输入

> 第一行包含一个整数 $n (1≤n≤1500)$ - 排列的大小。
第二行包含 $n$ 个整数 $a_1,a_2,......,a_n (1≤a_i≤n)$ --排列的元素。这些整数是成对不同的。
第三行包含一个整数 $m (1≤m≤2·10^5)$ - 要处理的查询次数。
接下来是 $m$ 行， $i$ -行包含两个整数 $l_i 、 r_i$  。 $(1≤l_i≤r_i≤n)$，表示 $i$ 次查询是要逆转排列的 $[l_i, r_i]$ 段。所有查询都是相继进行的。



## 输出

> 打印 m 行。如果 i -th 查询后的排列中的反转次数为奇数，则其中的 i -th 必须等于奇数，否则为偶数。

---

## 我的思路
**数学/集合**

##

> - 查询逆序对的奇偶性，我们从集合地角度思考，假设当前选中的子数组左右端点为 $l, r$ 。那么长度集为 `len = (r-l+1)` 。那么可以组成的序对个数为 `len*(len-1)/2`。如果`逆序对`的个数为 `x` , 那么顺序对即是逆序对的补集，设 `顺序对` 个数为 `y`，那么 `x+y = len*(len-1)/2` ，反转后逆序对就变成了顺序对，顺序对就变为了逆序对，那么逆序对的增量为 `len*(len-1)/2-2*x(x为原来逆序对的个数)` 。因为 `2*x`为永远为**偶数** ，那么我们只需要判断 `len*(len-1)/2` 的奇偶性即可，我们第一次反转子数组新的逆序对个数即为 `len*(len-1)/2-2*x + base（最初始的）`。后续只需要判断奇偶性就可。如果 `len*（len-1）/2` 为偶数，那么总数奇偶性不变（上一次操作是啥就是啥），若为奇数就反转奇偶性就可


##
---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go


package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
)

type (
	i64 int64
	i32 int32
)

func solve(in io.Reader, out io.Writer) {
	//var T int
	//for Fscan(in, &T); T > 0; T-- {
	var n int
	Fscan(in, &n)
	a := make([]int, n)
	for i := 0; i < n; i++ {
		Fscan(in, &a[i])
	}
	var m int
	Fscan(in, &m)
	base := 0
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			if a[j] < a[i] {
				base++
			}
		}
	}
	var l, r int
	odd := false
	even := false
	if base%2 == 0 {
		even = true
	} else {
		odd = true
	}
	for k := 0; k < m; k++ {
		Fscan(in, &l, &r)
		ll := r - l + 1
		if (ll*(ll-1)/2)%2 == 1 {
			odd, even = even, odd
		}
		if even {
			Fprintln(out, "even")
		} else {
			Fprintln(out, "odd")
		}
	}
	//}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}



```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python



```
