# [1837D] [Bracket Coloring](https://codeforces.com/problemset/problem/1837/D)

## 题目描述
A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters "1" and "+" between the original characters of the sequence. For example:

-   the bracket sequences "()()" and "(())" are regular (the resulting expressions are: "(1)+(1)" and "((1+1)+1)");
-   the bracket sequences ")(", "(" and ")" are not.

A bracket sequence is called beautiful if one of the following conditions is satisfied:

-   it is a regular bracket sequence;
-   if the order of the characters in this sequence is reversed, it becomes a regular bracket sequence.

For example, the bracket sequences "()()", "(())", ")))(((", "))()((" are beautiful.

You are given a bracket sequence $s$. You have to color it in such a way that:

-   every bracket is colored into one color;
-   for every color, there is at least one bracket colored into that color;
-   for every color, if you write down the sequence of brackets having that color in the order they appear, you will get a beautiful bracket sequence.

Color the given bracket sequence $s$ into the **minimum** number of colors according to these constraints, or report that it is impossible.


---

## 题目大意
给你一个长度为 n 的括号序列 s。我们将类似于 `(()()())` 成为一个合法的括号序列。而 `)(` 不是一个合法的括号序列。但是如果我们将 `)(` 反转，得到 `)(`，这成为**美丽序列**。

例如 `"()()", "(())", ")))(((", "))()(("` ，这些都是**美丽序列**。

现在让你对每个括号进行染色（标成数字，从 $1$ 开始），染成同样颜色的括号序列必须是**美丽序列**。如果可以，输出最小的颜色数以及染色方案，否则输出 $-1$ 。


---

## 输入




## 输出

> 

---

## 我的思路

**构造/贪心**

> 直觉，这个问题答案要么是**不可能($-1$)** ，要么这个序列本身就是**美丽序列**，要么得**拆开成两个**美丽序列。

> 对于一个美丽序列，我们可以是一个**正序列**，也可以是一个**反序列**。我们使用一个 $cnt$ 来计数，如果当前是 `(` ，那么 $cnt$ 就**加一**，如果当前是 `)` ，那么 $cnt$ 就**减一**。注意到，如果是个**正的合法序列**，那么序列中**所有的** $cnt$ 都是**非负数**，并且**结尾** $cnt$ 为 $0$ 。如果是个**反的合法序列**，那么序列中所有的 $cnt$ 都是**非正数**，并且 **结尾** $cnt$ 也为 $0$。所以我们可以再另外用一个 $mask$ 数组来标记当前位置的 $cnt$ 状态，便于答案的输出。如果 $mask[i] >= 0$ 就输出 $1$ ，否则输出 $2$ 。我们还要判断 $s$ **本身**是不是就是一个美丽序列，**如果是**直接全部输出 $1$ 就好了。

> 如果 $len(s)$ 是奇数或 $s$ 中 `(`, `)` 数量不一样，那么一定不可能。



---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"strings"
)

const inf = 0x3f3f3f3f

type (
	i8  = int8
	i64 = int64
	i32 = int32
	u64 = uint64
	u32 = uint32
	f32 = float32
	f64 = float64
)

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n int
		Fscan(in, &n)
		var s string
		Fscan(in, &s)

		if n&1 == 1 || strings.Count(s, "(") != n/2 {
			Fprintln(out, -1)
			continue
		}

		mask := make([]int, n)
		cnt := 0

		has1, has2 := false, false

		for i, c := range s {
			if c == '(' {
				if cnt >= 0 {
					mask[i] = 1
					has1 = true
				} else {
					mask[i] = 2
					has2 = true
				}
				cnt++
			} else {
				cnt--
				if cnt >= 0 {
					mask[i] = 1
					has1 = true
				} else {
					mask[i] = 2
					has2 = true
				}
			}
		}

		if has1 && has2 {
			Fprintln(out, 2)
			for _, c := range mask {
				Fprint(out, c, " ")
			}
		} else {
			Fprintln(out, 1)
			for range n {
				Fprint(out, 1, " ")
			}
		}
		Fprintln(out)
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func abs64(x i64) i64 {
	if x < 0 {
		return -x
	}
	return x
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

func max64(x, y i64) i64 {
	if x > y {
		return x
	}
	return y
}

func min64(x, y i64) i64 {
	if x < y {
		return x
	}
	return y
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++
```
---
## Python 代码

```Python
```

---

## JavaScript 代码

```JavaScript
```
