# [cf2137E] [Mexification](https://codeforces.com/problemset/problem/2137/E)
## 题目描述 

> 

---
## 题目大意

> 给你一个大小为 $n$ 的数组 $a$ 和一个整数 $k$ 。你需要执行下面的程序 $k$ 次：
对每个元素 $a_i$ 设置 $a_i$为 $mex∗(a_1,a_2,…,a_{i−1},a_{i+1},a_{i+2},…,a_n)$ 。换句话说，将 $a_i$ 设置为数组中所有其他元素的 $mex$ 。**同时对数组中的所有元素进行设置** 。请找出所有 $k$ 操作后数组中元素的总和。
> 
 **整数集合 d1,d2,…,dk的最小外差(MEX)定义为在集合中不出现的最小非负整数 x。**



## 输入

> Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \le t \le 10^4$). The description of the test cases follows.
The first line contains two integers $n$ and $k$ ($2 \leq n \leq 2\cdot 10^5, 1 \leq k \leq 10^9$) – the number of elements in $a$ and the number of operations done.
The second line contains $n$ integers $a_1,a_2,\ldots,a_n$ ($0 \leq a_i \leq n$).
It is guaranteed that the sum of $n$ over all test cases does not exceed $2\cdot 10^5$.



## 输出

> For each test case, output the sum of elements after all $k$ operations on a new line.

---

## 我的思路
**数学/思维**


> 先想想 k=1 的情况，理解题意。操作一次后：对于大于 $mex(a)$ 的数，都变成了 $mex(a)$ 。对于小于 $mex(a)$ 的数，如果这个数出现不止一次，那么变成 $mex(a)$，否则不变（不动点）。例如 `0123347 -> 0125545`。

> 设只出现一次的数的集合为 $b$。对于 $k>=2$，有如下三种情况：
- `mex(b) = mex(a)`，例如 `01245 -> 01233 -> 01244 -> 01233 -> ...` 无限循环，周期为 `2`。
- `mex(b) = mex(a)` 且 `len(b) = n-1` 的特殊情况，例如 `0124 -> 0123 -> 0123 -> 0123 -> ...` 无限循环，周期为 `1`。
- `mex(b) < mex(a)`，例如 `0123347 -> 0125545 -> 0123333 -> 0124444 -> 0123333 -> ...` 无限循环，周期为 `2`。
算出 $mex(b)$ 后可以用数学公式 $O(1)$ 解决，见代码。


---

## 时间复杂度

$O()$

---

## 空间复杂度

$O()$

---

## Go 代码

```Go
package main

import (
	"bufio"
	. "fmt"
	"io"
	"os"
	"sort"
)

type (
	i64 = int64
	i32 = int32
)

func gett(a []int) int {
	tar := 0

	t := map[int]bool{}
	for _, x := range a {
		t[x] = true
	}
	tt := make([]int, 0, len(t))
	for x := range t {
		tt = append(tt, x)
	}
	sort.Slice(tt, func(i, j int) bool {
		return tt[i] < tt[j]
	})

	for _, x := range tt {
		if tar != x {
			break
		}
		tar++
	}
	return tar
}

func solve(in io.Reader, out io.Writer) {
	var T int
	for Fscan(in, &T); T > 0; T-- {
		var n, k, v int
		Fscan(in, &n, &k)
		cnt := make([]int, n+1)
		for range n {
			Fscan(in, &v)
			cnt[v]++
		}

		m := 0
		for cnt[m] == 1 {
			m++
		}

		mex := m
		for cnt[mex] > 0 {
			mex++
		}

		if k == 1 {
			ans := mex * n
			for i, c := range cnt[:mex] {
				if c == 1 {
					ans += i - mex
				}
			}
			Fprintln(out, ans)
		} else if mex > m {
			Fprintln(out, m*(m-1)/2+(m+k%2)*(n-m))
		} else if n-m == 1 {
			Fprintln(out, n*(n-1)/2)
		} else {
			Fprintln(out, m*(m-1)/2+(m+1-k%2)*(n-m))
		}
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	solve(bufio.NewReader(os.Stdin), os.Stdout)
}

```
---

## C++ 代码

```C++




```
---
## Python 代码

```Python



```
